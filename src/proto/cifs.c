// -*- c-basic-offset: 4; c-backslash-column: 79; indent-tabs-mode: nil -*-
// vim:sw=4 ts=4 sts=4 expandtab
/* Copyright 2010, SecurActive.
 *
 * This file is part of Junkie.
 *
 * Junkie is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Junkie is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Junkie.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <iconv.h>
#include "junkie/proto/cifs.h"
#include "junkie/tools/objalloc.h"
#include "junkie/proto/cursor.h"
#include "junkie/proto/tcp.h"
#include "junkie/proto/ip.h"
#include "junkie/proto/der.h"
#include "junkie/proto/netbios.h"

#undef LOG_CAT
#define LOG_CAT proto_cifs_log_category

LOG_CATEGORY_DEF(proto_cifs);

#define SMB_HEADER_SIZE sizeof(struct smb_hdr)
#define SMB2_HEADER_SIZE sizeof(struct smb2_hdr)

static char const *smb_file_info_levels_2_str(enum smb_file_info_levels level)
{
    if ((level & PASS_THROUGH_LEVEL_OF_INTEREST) == PASS_THROUGH_LEVEL_OF_INTEREST) {
        switch ((level & ~PASS_THROUGH_LEVEL_OF_INTEREST)) {
            case FILE_DIRECTORY_INFORMATION              : return "FILE_DIRECTORY_INFORMATION";
            case FILE_FULL_DIRECTORY_INFORMATION         : return "FILE_FULL_DIRECTORY_INFORMATION";
            case FILE_BOTH_DIRECTORY_INFORMATION         : return "FILE_BOTH_DIRECTORY_INFORMATION";
            case FILE_BASIC_INFORMATION                  : return "FILE_BASIC_INFORMATION";
            case FILE_STANDARD_INFORMATION               : return "FILE_STANDARD_INFORMATION";
            case FILE_INTERNAL_INFORMATION               : return "FILE_INTERNAL_INFORMATION";
            case FILE_EA_INFORMATION                     : return "FILE_EA_INFORMATION";
            case FILE_ACCESS_INFORMATION                 : return "FILE_ACCESS_INFORMATION";
            case FILE_NAME_INFORMATION                   : return "FILE_NAME_INFORMATION";
            case FILE_RENAME_INFORMATION                 : return "FILE_RENAME_INFORMATION";
            case FILE_LINK_INFORMATION                   : return "FILE_LINK_INFORMATION";
            case FILE_NAMES_INFORMATION                  : return "FILE_NAMES_INFORMATION";
            case FILE_DISPOSITION_INFORMATION            : return "FILE_DISPOSITION_INFORMATION";
            case FILE_POSITION_INFORMATION               : return "FILE_POSITION_INFORMATION";
            case FILE_FULL_EA_INFORMATION                : return "FILE_FULL_EA_INFORMATION";
            case FILE_MODE_INFORMATION                   : return "FILE_MODE_INFORMATION";
            case FILE_ALIGNMENT_INFORMATION              : return "FILE_ALIGNMENT_INFORMATION";
            case FILE_ALL_INFORMATION                    : return "FILE_ALL_INFORMATION";
            case FILE_ALLOCATION_INFORMATION             : return "FILE_ALLOCATION_INFORMATION";
            case FILE_END_OF_FILE_INFORMATION            : return "FILE_END_OF_FILE_INFORMATION";
            case FILE_ALTERNATE_NAME_INFORMATION         : return "FILE_ALTERNATE_NAME_INFORMATION";
            case FILE_STREAM_INFORMATION                 : return "FILE_STREAM_INFORMATION";
            case FILE_PIPE_INFORMATION                   : return "FILE_PIPE_INFORMATION";
            case FILE_PIPE_LOCAL_INFORMATION             : return "FILE_PIPE_LOCAL_INFORMATION";
            case FILE_PIPE_REMOTE_INFORMATION            : return "FILE_PIPE_REMOTE_INFORMATION";
            case FILE_MAILSLOT_QUERY_INFORMATION         : return "FILE_MAILSLOT_QUERY_INFORMATION";
            case FILE_MAILSLOT_SET_INFORMATION           : return "FILE_MAILSLOT_SET_INFORMATION";
            case FILE_COMPRESSION_INFORMATION            : return "FILE_COMPRESSION_INFORMATION";
            case FILE_OBJECT_ID_INFORMATION              : return "FILE_OBJECT_ID_INFORMATION";
            case FILE_MOVE_CLUSTER_INFORMATION           : return "FILE_MOVE_CLUSTER_INFORMATION";
            case FILE_QUOTA_INFORMATION                  : return "FILE_QUOTA_INFORMATION";
            case FILE_REPARSE_POINT_INFORMATION          : return "FILE_REPARSE_POINT_INFORMATION";
            case FILE_NETWORK_OPEN_INFORMATION           : return "FILE_NETWORK_OPEN_INFORMATION";
            case FILE_ATTRIBUTE_TAG_INFORMATION          : return "FILE_ATTRIBUTE_TAG_INFORMATION";
            case FILE_TRACKING_INFORMATION               : return "FILE_TRACKING_INFORMATION";
            case FILE_ID_BOTH_DIRECTORY_INFORMATION      : return "FILE_ID_BOTH_DIRECTORY_INFORMATION";
            case FILE_ID_FULL_DIRECTORY_INFORMATION      : return "FILE_ID_FULL_DIRECTORY_INFORMATION";
            case FILE_VALID_DATA_LENGTH_INFORMATION      : return "FILE_VALID_DATA_LENGTH_INFORMATION";
            case FILE_SHORT_NAME_INFORMATION             : return "FILE_SHORT_NAME_INFORMATION";
            case FILE_SFIO_RESERVE_INFORMATION           : return "FILE_SFIO_RESERVE_INFORMATION";
            case FILE_SFIO_VOLUME_INFORMATION            : return "FILE_SFIO_VOLUME_INFORMATION";
            case FILE_HARD_LINK_INFORMATION              : return "FILE_HARD_LINK_INFORMATION";
            case FILE_NORMALIZED_NAME_INFORMATION        : return "FILE_NORMALIZED_NAME_INFORMATION";
            case FILE_ID_GLOBAL_TX_DIRECTORY_INFORMATION : return "FILE_ID_GLOBAL_TX_DIRECTORY_INFORMATION";
            case FILE_STANDARD_LINK_INFORMATION          : return "FILE_STANDARD_LINK_INFORMATION";
        }
    }
    switch (level) {
        case QUERY_FILE_UNIX_BASIC           : return "QUERY_FILE_UNIX_BASIC";
        case QUERY_FILE_UNIX_LINK            : return "QUERY_FILE_UNIX_LINK";
        case QUERY_POSIX_ACL                 : return "QUERY_POSIX_ACL";
        case QUERY_XATTR                     : return "QUERY_XATTR";
        case QUERY_ATTR_FLAGS                : return "QUERY_ATTR_FLAGS";
        case QUERY_POSIX_PERMISSION          : return "QUERY_POSIX_PERMISSION";
        case QUERY_POSIX_LOCK                : return "QUERY_POSIX_LOCK";
        case SMB_POSIX_PATH_OPEN             : return "SMB_POSIX_PATH_OPEN";
        case SMB_POSIX_PATH_UNLINK           : return "SMB_POSIX_PATH_UNLINK";
        case SMB_QUERY_FILE_UNIX_INFO2       : return "SMB_QUERY_FILE_UNIX_INFO2";
        case SMB_INFO_STANDARD               : return "SMB_INFO_STANDARD";
        case SMB_INFO_QUERY_EA_SIZE          : return "SMB_INFO_QUERY_EA_SIZE";
        case SMB_INFO_QUERY_EA_FROM_LIST     : return "SMB_INFO_QUERY_EA_FROM_LIST";
        case SMB_INFO_QUERY_ALL_EAS          : return "SMB_INFO_QUERY_ALL_EAS";
        case SMB_INFO_NAME_VALID             : return "SMB_INFO_NAME_VALID";
        case SMB_QUERY_FILE_BASIC_INFO       : return "SMB_QUERY_FILE_BASIC_INFO";
        case SMB_QUERY_FILE_STANDARD_INFO    : return "SMB_QUERY_FILE_STANDARD_INFO";
        case SMB_QUERY_FILE_EA_INFO          : return "SMB_QUERY_FILE_EA_INFO";
        case SMB_QUERY_FILE_NAME_INFO        : return "SMB_QUERY_FILE_NAME_INFO";
        case SMB_QUERY_FILE_ALL_INFO         : return "SMB_QUERY_FILE_ALL_INFO";
        case SMB_QUERY_FILE_ALT_NAME_INFO    : return "SMB_QUERY_FILE_ALT_NAME_INFO";
        case SMB_QUERY_FILE_STREAM_INFO      : return "SMB_QUERY_FILE_STREAM_INFO";
        case SMB_QUERY_FILE_COMPRESSION_INFO : return "SMB_QUERY_FILE_COMPRESSION_INFO";
        default                              : return tempstr_printf("Unknown (0x%"PRIx32")", level);
    }
}

static char const *smb_command_2_str(enum smb_command command)
{
    switch (command) {
        case SMB_COM_CREATE_DIRECTORY       : return "SMB_COM_CREATE_DIRECTORY";
        case SMB_COM_DELETE_DIRECTORY       : return "SMB_COM_DELETE_DIRECTORY";
        case SMB_COM_OPEN                   : return "SMB_COM_OPEN";
        case SMB_COM_CREATE                 : return "SMB_COM_CREATE";
        case SMB_COM_CLOSE                  : return "SMB_COM_CLOSE";
        case SMB_COM_FLUSH                  : return "SMB_COM_FLUSH";
        case SMB_COM_DELETE                 : return "SMB_COM_DELETE";
        case SMB_COM_RENAME                 : return "SMB_COM_RENAME";
        case SMB_COM_QUERY_INFORMATION      : return "SMB_COM_QUERY_INFORMATION";
        case SMB_COM_SET_INFORMATION        : return "SMB_COM_SET_INFORMATION";
        case SMB_COM_READ                   : return "SMB_COM_READ";
        case SMB_COM_WRITE                  : return "SMB_COM_WRITE";
        case SMB_COM_LOCK_BYTE_RANGE        : return "SMB_COM_LOCK_BYTE_RANGE";
        case SMB_COM_UNLOCK_BYTE_RANGE      : return "SMB_COM_UNLOCK_BYTE_RANGE";
        case SMB_COM_CREATE_TEMPORARY       : return "SMB_COM_CREATE_TEMPORARY";
        case SMB_COM_CREATE_NEW             : return "SMB_COM_CREATE_NEW";
        case SMB_COM_CHECK_DIRECTORY        : return "SMB_COM_CHECK_DIRECTORY";
        case SMB_COM_PROCESS_EXIT           : return "SMB_COM_PROCESS_EXIT";
        case SMB_COM_SEEK                   : return "SMB_COM_SEEK";
        case SMB_COM_LOCK_AND_READ          : return "SMB_COM_LOCK_AND_READ";
        case SMB_COM_WRITE_AND_UNLOCK       : return "SMB_COM_WRITE_AND_UNLOCK";
        case SMB_COM_READ_RAW               : return "SMB_COM_READ_RAW";
        case SMB_COM_READ_MPX               : return "SMB_COM_READ_MPX";
        case SMB_COM_READ_MPX_SECONDARY     : return "SMB_COM_READ_MPX_SECONDARY";
        case SMB_COM_WRITE_RAW              : return "SMB_COM_WRITE_RAW";
        case SMB_COM_WRITE_MPX              : return "SMB_COM_WRITE_MPX";
        case SMB_COM_WRITE_MPX_SECONDARY    : return "SMB_COM_WRITE_MPX_SECONDARY";
        case SMB_COM_WRITE_COMPLETE         : return "SMB_COM_WRITE_COMPLETE";
        case SMB_COM_QUERY_SERVER           : return "SMB_COM_QUERY_SERVER";
        case SMB_COM_SET_INFORMATION2       : return "SMB_COM_SET_INFORMATION2";
        case SMB_COM_QUERY_INFORMATION2     : return "SMB_COM_QUERY_INFORMATION2";
        case SMB_COM_LOCKING_ANDX           : return "SMB_COM_LOCKING_ANDX";
        case SMB_COM_TRANSACTION            : return "SMB_COM_TRANSACTION";
        case SMB_COM_TRANSACTION_SECONDARY  : return "SMB_COM_TRANSACTION_SECONDARY";
        case SMB_COM_IOCTL                  : return "SMB_COM_IOCTL";
        case SMB_COM_IOCTL_SECONDARY        : return "SMB_COM_IOCTL_SECONDARY";
        case SMB_COM_COPY                   : return "SMB_COM_COPY";
        case SMB_COM_MOVE                   : return "SMB_COM_MOVE";
        case SMB_COM_ECHO                   : return "SMB_COM_ECHO";
        case SMB_COM_WRITE_AND_CLOSE        : return "SMB_COM_WRITE_AND_CLOSE";
        case SMB_COM_OPEN_ANDX              : return "SMB_COM_OPEN_ANDX";
        case SMB_COM_READ_ANDX              : return "SMB_COM_READ_ANDX";
        case SMB_COM_WRITE_ANDX             : return "SMB_COM_WRITE_ANDX";
        case SMB_COM_NEW_FILE_SIZE          : return "SMB_COM_NEW_FILE_SIZE";
        case SMB_COM_CLOSE_AND_TREE_DISC    : return "SMB_COM_CLOSE_AND_TREE_DISC";
        case SMB_COM_TRANSACTION2           : return "SMB_COM_TRANSACTION2";
        case SMB_COM_TRANSACTION2_SECONDARY : return "SMB_COM_TRANSACTION2_SECONDARY";
        case SMB_COM_FIND_CLOSE2            : return "SMB_COM_FIND_CLOSE2";
        case SMB_COM_FIND_NOTIFY_CLOSE      : return "SMB_COM_FIND_NOTIFY_CLOSE";
        case SMB_COM_TREE_CONNECT           : return "SMB_COM_TREE_CONNECT";
        case SMB_COM_TREE_DISCONNECT        : return "SMB_COM_TREE_DISCONNECT";
        case SMB_COM_NEGOCIATE              : return "SMB_COM_NEGOCIATE";
        case SMB_COM_SESSION_SETUP_ANDX     : return "SMB_COM_SESSION_SETUP_ANDX";
        case SMB_COM_LOGOFF_ANDX            : return "SMB_COM_LOGOFF_ANDX";
        case SMB_COM_TREE_CONNECT_ANDX      : return "SMB_COM_TREE_CONNECT_ANDX";
        case SMB_COM_SECURITY_PACKAGE_ANDX  : return "SMB_COM_SECURITY_PACKAGE_ANDX";
        case SMB_COM_QUERY_INFORMATION_DISK : return "SMB_COM_QUERY_INFORMATION_DISK";
        case SMB_COM_SEARCH                 : return "SMB_COM_SEARCH";
        case SMB_COM_FIND                   : return "SMB_COM_FIND";
        case SMB_COM_FIND_UNIQUE            : return "SMB_COM_FIND_UNIQUE";
        case SMB_COM_FIND_CLOSE             : return "SMB_COM_FIND_CLOSE";
        case SMB_COM_NT_TRANSACT            : return "SMB_COM_NT_TRANSACT";
        case SMB_COM_NT_TRANSACT_SECONDARY  : return "SMB_COM_NT_TRANSACT_SECONDARY";
        case SMB_COM_NT_CREATE_ANDX         : return "SMB_COM_NT_CREATE_ANDX";
        case SMB_COM_NT_CANCEL              : return "SMB_COM_NT_CANCEL";
        case SMB_COM_NT_RENAME              : return "SMB_COM_NT_RENAME";
        case SMB_COM_OPEN_PRINT_FILE        : return "SMB_COM_OPEN_PRINT_FILE";
        case SMB_COM_WRITE_PRINT_FILE       : return "SMB_COM_WRITE_PRINT_FILE";
        case SMB_COM_CLOSE_PRINT_FILE       : return "SMB_COM_CLOSE_PRINT_FILE";
        case SMB_COM_GET_PRINT_FILE         : return "SMB_COM_GET_PRINT_FILE";
        case SMB_COM_READ_BULK              : return "SMB_COM_READ_BULK";
        case SMB_COM_WRITE_BULK             : return "SMB_COM_WRITE_BULK";
        case SMB_COM_WRITE_BULK_DATA        : return "SMB_COM_WRITE_BULK_DATA";
        case SMB_COM_INVALID                : return "SMB_COM_INVALID";
        case SMB_COM_NO_ANDX_COMMAND        : return "SMB_COM_NO_ANDX_COMMAND";
        default                             : return tempstr_printf("Unknown (0x%"PRIx32")", command);
    }
}

static char const *smb2_command_2_str(enum smb2_command command)
{
    switch (command) {
        case SMB2_COM_NEGOTIATE       : return "SMB2_COM_NEGOTIATE";
        case SMB2_COM_SESSION_SETUP   : return "SMB2_COM_SESSION_SETUP";
        case SMB2_COM_LOGOFF          : return "SMB2_COM_LOGOFF";
        case SMB2_COM_TREE_CONNECT    : return "SMB2_COM_TREE_CONNECT";
        case SMB2_COM_TREE_DISCONNECT : return "SMB2_COM_TREE_DISCONNECT";
        case SMB2_COM_CREATE          : return "SMB2_COM_CREATE";
        case SMB2_COM_CLOSE           : return "SMB2_COM_CLOSE";
        case SMB2_COM_FLUSH           : return "SMB2_COM_FLUSH";
        case SMB2_COM_READ            : return "SMB2_COM_READ";
        case SMB2_COM_WRITE           : return "SMB2_COM_WRITE";
        case SMB2_COM_LOCK            : return "SMB2_COM_LOCK";
        case SMB2_COM_IOCTL           : return "SMB2_COM_IOCTL";
        case SMB2_COM_CANCEL          : return "SMB2_COM_CANCEL";
        case SMB2_COM_ECHO            : return "SMB2_COM_ECHO";
        case SMB2_COM_QUERY_DIRECTORY : return "SMB2_COM_QUERY_DIRECTORY";
        case SMB2_COM_CHANGE_NOTIFY   : return "SMB2_COM_CHANGE_NOTIFY";
        case SMB2_COM_QUERY_INFO      : return "SMB2_COM_QUERY_INFO";
        case SMB2_COM_SET_INFO        : return "SMB2_COM_SET_INFO";
        case SMB2_COM_OPLOCK_BREAK    : return "SMB2_COM_OPLOCK_BREAK";
        default                       : return tempstr_printf("Unknown (0x%"PRIx32")", command);
    }
}

static char const *smb_trans2_subcmd_2_str(enum smb_trans2_subcommand command)
{
    switch (command) {
        case SMB_TRANS2_OPEN2                    : return "SMB_TRANS2_OPEN2";
        case SMB_TRANS2_FIND_FIRST2              : return "SMB_TRANS2_FIND_FIRST2";
        case SMB_TRANS2_FIND_NEXT2               : return "SMB_TRANS2_FIND_NEXT2";
        case SMB_TRANS2_QUERY_FS_INFO            : return "SMB_TRANS2_QUERY_FS_INFO";
        case SMB_TRANS2_SET_FS_INFORMATION       : return "SMB_TRANS2_SET_FS_INFORMATION";
        case SMB_TRANS2_QUERY_PATH_INFORMATION   : return "SMB_TRANS2_QUERY_PATH_INFORMATION";
        case SMB_TRANS2_SET_PATH_INFORMATION     : return "SMB_TRANS2_SET_PATH_INFORMATION";
        case SMB_TRANS2_QUERY_FILE_INFORMATION   : return "SMB_TRANS2_QUERY_FILE_INFORMATION";
        case SMB_TRANS2_SET_FILE_INFORMATION     : return "SMB_TRANS2_SET_FILE_INFORMATION";
        case SMB_TRANS2_FSCTL                    : return "SMB_TRANS2_FSCTL";
        case SMB_TRANS2_IOCTL2                   : return "SMB_TRANS2_IOCTL2";
        case SMB_TRANS2_FIND_NOTIFY_FIRST        : return "SMB_TRANS2_FIND_NOTIFY_FIRST";
        case SMB_TRANS2_FIND_NOTIFY_NEXT         : return "SMB_TRANS2_FIND_NOTIFY_NEXT";
        case SMB_TRANS2_CREATE_DIRECTORY         : return "SMB_TRANS2_CREATE_DIRECTORY";
        case SMB_TRANS2_SESSION_SETUP            : return "SMB_TRANS2_SESSION_SETUP";
        case SMB_TRANS2_GET_DFS_REFERRAL         : return "SMB_TRANS2_GET_DFS_REFERRAL";
        case SMB_TRANS2_REPORT_DFS_INCONSISTENCY : return "SMB_TRANS2_REPORT_DFS_INCONSISTENCY";
        default                                  : return tempstr_printf("Unknown (0x%"PRIx32")", command);
    }
}

static char const *smb_transaction_subcmd_2_str(enum smb_transaction_subcommand command)
{
    switch (command) {
        case SMB_TRANS_CALL_NMPIPE               : return "SMB_TRANS_CALL_NMPIPE";
        case SMB_TRANS_PEEK_NMPIPE               : return "SMB_TRANS_PEEK_NMPIPE";
        case SMB_TRANS_QUERY_NMPIPE_INFO         : return "SMB_TRANS_QUERY_NMPIPE_INFO";
        case SMB_TRANS_QUERY_NMPIPE_STATE        : return "SMB_TRANS_QUERY_NMPIPE_STATE";
        case SMB_TRANS_RAW_READ_NMPIPE           : return "SMB_TRANS_RAW_READ_NMPIPE";
        case SMB_TRANS_RAW_WRITE_NMPIPE          : return "SMB_TRANS_RAW_WRITE_NMPIPE";
        case SMB_TRANS_READ_NMPIPE               : return "SMB_TRANS_READ_NMPIPE";
        case SMB_TRANS_SET_NMPIPE_STATE          : return "SMB_TRANS_SET_NMPIPE_STATE";
        case SMB_TRANS_TRANSACT_NMPIPE           : return "SMB_TRANS_TRANSACT_NMPIPE";
        case SMB_TRANS_WAIT_NMPIPE               : return "SMB_TRANS_WAIT_NMPIPE";
        case SMB_TRANS_WRITE_NMPIPE              : return "SMB_TRANS_WRITE_NMPIPE";
        default                                  : return tempstr_printf("Unknown (0x%"PRIx32")", command);
    }
}

static char const *smb_nt_trans_subcmd_2_str(enum smb_nt_transact_subcommand command)
{
    switch (command) {
        case SMB_NT_TRANSACT_CREATE                  : return "SMB_NT_TRANSACT_CREATE";
        case SMB_NT_TRANSACT_IOCTL                   : return "SMB_NT_TRANSACT_IOCTL";
        case SMB_NT_TRANSACT_NOTIFY_CHANGE           : return "SMB_NT_TRANSACT_NOTIFY_CHANGE";
        case SMB_NT_TRANSACT_SET_SECURITY_DESC       : return "SMB_NT_TRANSACT_SET_SECURITY_DESC";
        case SMB_NT_TRANSACT_RENAME                  : return "SMB_NT_TRANSACT_RENAME";
        case SMB_NT_TRANSACT_QUERY_SECURITY_DESC     : return "SMB_NT_TRANSACT_QUERY_SECURITY_DESC";
        default                                      : return tempstr_printf("Unknown (0x%"PRIx32")", command);
    }
}


static char const *smb_status_2_str(enum smb_status status)
{
    switch (status) {
        case SMB_STATUS_OK: return "SMB_STATUS_OK";
        case SMB_STATUS_ACCESS_DENIED: return "SMB_STATUS_ACCESS_DENIED";
        case SMB_STATUS_NETWORK_ACCESS_DENIED: return "SMB_STATUS_NETWORK_ACCESS_DENIED";
        case SMB_STATUS_ACCOUNT_DISABLED: return "SMB_STATUS_ACCOUNT_DISABLED";
        case SMB_STATUS_ACCOUNT_EXPIRED: return "SMB_STATUS_ACCOUNT_EXPIRED";
        case SMB_STATUS_ALREADY_COMMITTED: return "SMB_STATUS_ALREADY_COMMITTED";
        case SMB_STATUS_BAD_DEVICE_TYPE: return "SMB_STATUS_BAD_DEVICE_TYPE";
        case SMB_STATUS_BAD_NETWORK_NAME: return "SMB_STATUS_BAD_NETWORK_NAME";
        case SMB_STATUS_BUFFER_OVERFLOW: return "SMB_STATUS_BUFFER_OVERFLOW";
        case SMB_STATUS_CANNOT_DELETE: return "SMB_STATUS_CANNOT_DELETE";
        case SMB_STATUS_CRC_ERROR: return "SMB_STATUS_CRC_ERROR";
        case SMB_STATUS_DATA_ERROR: return "SMB_STATUS_DATA_ERROR";
        case SMB_STATUS_DATA_ERROR_UNUSED: return "SMB_STATUS_DATA_ERROR_UNUSED";
        case SMB_STATUS_DELETE_PENDING: return "SMB_STATUS_DELETE_PENDING";
        case SMB_STATUS_DEVICE_PAPER_EMPTY: return "SMB_STATUS_DEVICE_PAPER_EMPTY";
        case SMB_STATUS_DFS_EXIT_PATH_FOUND: return "SMB_STATUS_DFS_EXIT_PATH_FOUND";
        case SMB_STATUS_DIRECTORY_NOT_EMPTY: return "SMB_STATUS_DIRECTORY_NOT_EMPTY";
        case SMB_STATUS_DISK_CORRUPT_ERROR: return "SMB_STATUS_DISK_CORRUPT_ERROR";
        case SMB_STATUS_DISK_FULL: return "SMB_STATUS_DISK_FULL";
        case SMB_STATUS_EAS_NOT_SUPPORTED: return "SMB_STATUS_EAS_NOT_SUPPORTED";
        case SMB_STATUS_EA_TOO_LARGE: return "SMB_STATUS_EA_TOO_LARGE";
        case SMB_STATUS_END_OF_FILE: return "SMB_STATUS_END_OF_FILE";
        case SMB_STATUS_FILE_CLOSED: return "SMB_STATUS_FILE_CLOSED";
        case SMB_STATUS_FILE_DELETED: return "SMB_STATUS_FILE_DELETED";
        case SMB_STATUS_FILE_IS_A_DIRECTORY: return "SMB_STATUS_FILE_IS_A_DIRECTORY";
        case SMB_STATUS_FILE_LOCK_CONFLICT: return "SMB_STATUS_FILE_LOCK_CONFLICT";
        case SMB_STATUS_FILE_RENAMED: return "SMB_STATUS_FILE_RENAMED";
        case SMB_STATUS_HANDLE_NOT_CLOSABLE: return "SMB_STATUS_HANDLE_NOT_CLOSABLE";
        case SMB_STATUS_ILLEGAL_FUNCTION: return "SMB_STATUS_ILLEGAL_FUNCTION";
        case SMB_STATUS_INSTANCE_NOT_AVAILABLE: return "SMB_STATUS_INSTANCE_NOT_AVAILABLE";
        case SMB_STATUS_INSUFF_SERVER_RESOURCES: return "SMB_STATUS_INSUFF_SERVER_RESOURCES";
        case SMB_STATUS_INVALID_DEVICE_REQUEST: return "SMB_STATUS_INVALID_DEVICE_REQUEST";
        case SMB_STATUS_INVALID_DEVICE_STATE: return "SMB_STATUS_INVALID_DEVICE_STATE";
        case SMB_STATUS_INVALID_HANDLE: return "SMB_STATUS_INVALID_HANDLE";
        case SMB_STATUS_INVALID_INFO_CLASS: return "SMB_STATUS_INVALID_INFO_CLASS";
        case SMB_STATUS_INVALID_LOCK_SEQUENCE: return "SMB_STATUS_INVALID_LOCK_SEQUENCE";
        case SMB_STATUS_INVALID_LOGON_HOURS: return "SMB_STATUS_INVALID_LOGON_HOURS";
        case SMB_STATUS_INVALID_PARAMETER: return "SMB_STATUS_INVALID_PARAMETER";
        case SMB_STATUS_INVALID_PIPE_STATE: return "SMB_STATUS_INVALID_PIPE_STATE";
        case SMB_STATUS_INVALID_PORT_HANDLE: return "SMB_STATUS_INVALID_PORT_HANDLE";
        case SMB_STATUS_INVALID_READ_MODE: return "SMB_STATUS_INVALID_READ_MODE";
        case SMB_STATUS_INVALID_SMB: return "SMB_STATUS_INVALID_SMB";
        case SMB_STATUS_INVALID_VIEW_SIZE: return "SMB_STATUS_INVALID_VIEW_SIZE";
        case SMB_STATUS_INVALID_WORKSTATION: return "SMB_STATUS_INVALID_WORKSTATION";
        case SMB_STATUS_IO_TIMEOUT: return "SMB_STATUS_IO_TIMEOUT";
        case SMB_STATUS_LOCK_NOT_GRANTED: return "SMB_STATUS_LOCK_NOT_GRANTED";
        case SMB_STATUS_LOGON_FAILURE: return "SMB_STATUS_LOGON_FAILURE";
        case SMB_STATUS_MEDIA_WRITE_PROTECTED: return "SMB_STATUS_MEDIA_WRITE_PROTECTED";
        case SMB_STATUS_MORE_PROCESSING_REQUIRED: return "SMB_STATUS_MORE_PROCESSING_REQUIRED";
        case SMB_STATUS_NETWORK_NAME_DELETED: return "SMB_STATUS_NETWORK_NAME_DELETED";
        case SMB_STATUS_NO_MEDIA_IN_DEVICE: return "SMB_STATUS_NO_MEDIA_IN_DEVICE";
        case SMB_STATUS_NO_MORE_FILES: return "SMB_STATUS_NO_MORE_FILES";
        case SMB_STATUS_NONEXISTENT_SECTOR: return "SMB_STATUS_NONEXISTENT_SECTOR";
        case SMB_STATUS_NO_SPOOL_SPACE: return "SMB_STATUS_NO_SPOOL_SPACE";
        case SMB_STATUS_NO_SUCH_DEVICE: return "SMB_STATUS_NO_SUCH_DEVICE";
        case SMB_STATUS_NO_SUCH_FILE: return "SMB_STATUS_NO_SUCH_FILE";
        case SMB_STATUS_NOTIFY_ENUM_DIR: return "SMB_STATUS_NOTIFY_ENUM_DIR";
        case SMB_STATUS_NOT_IMPLEMENTED: return "SMB_STATUS_NOT_IMPLEMENTED";
        case SMB_STATUS_NOT_SAME_DEVICE: return "SMB_STATUS_NOT_SAME_DEVICE";
        case SMB_STATUS_NOT_SUPPORTED: return "SMB_STATUS_NOT_SUPPORTED";
        case SMB_STATUS_OBJECT_NAME_COLLISION: return "SMB_STATUS_OBJECT_NAME_COLLISION";
        case SMB_STATUS_OBJECT_NAME_NOT_FOUND: return "SMB_STATUS_OBJECT_NAME_NOT_FOUND";
        case SMB_STATUS_OBJECT_PATH_INVALID: return "SMB_STATUS_OBJECT_PATH_INVALID";
        case SMB_STATUS_OBJECT_PATH_NOT_FOUND: return "SMB_STATUS_OBJECT_PATH_NOT_FOUND";
        case SMB_STATUS_OBJECT_PATH_SYNTAX_BAD: return "SMB_STATUS_OBJECT_PATH_SYNTAX_BAD";
        case SMB_STATUS_OBJECT_TYPE_MISMATCH: return "SMB_STATUS_OBJECT_TYPE_MISMATCH";
        case SMB_STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED: return "SMB_STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED";
        case SMB_STATUS_OS2_CANCEL_VIOLATION: return "SMB_STATUS_OS2_CANCEL_VIOLATION";
        case SMB_STATUS_OS2_CANNOT_COPY: return "SMB_STATUS_OS2_CANNOT_COPY";
        case SMB_STATUS_OS2_EA_ACCESS_DENIED: return "SMB_STATUS_OS2_EA_ACCESS_DENIED";
        case SMB_STATUS_OS2_EAS_DIDNT_FIT: return "SMB_STATUS_OS2_EAS_DIDNT_FIT";
        case SMB_STATUS_OS2_INVALID_ACCESS: return "SMB_STATUS_OS2_INVALID_ACCESS";
        case SMB_STATUS_OS2_INVALID_LEVEL: return "SMB_STATUS_OS2_INVALID_LEVEL";
        case SMB_STATUS_OS2_NEGATIVE_SEEK: return "SMB_STATUS_OS2_NEGATIVE_SEEK";
        case SMB_STATUS_OS2_NO_MORE_SIDS: return "SMB_STATUS_OS2_NO_MORE_SIDS";
        case SMB_STATUS_PASSWORD_EXPIRED: return "SMB_STATUS_PASSWORD_EXPIRED";
        case SMB_STATUS_PASSWORD_MUST_CHANGE: return "SMB_STATUS_PASSWORD_MUST_CHANGE";
        case SMB_STATUS_PATH_NOT_COVERED: return "SMB_STATUS_PATH_NOT_COVERED";
        case SMB_STATUS_PIPE_BUSY: return "SMB_STATUS_PIPE_BUSY";
        case SMB_STATUS_PIPE_CLOSING: return "SMB_STATUS_PIPE_CLOSING";
        case SMB_STATUS_PIPE_DISCONNECTED: return "SMB_STATUS_PIPE_DISCONNECTED";
        case SMB_STATUS_PIPE_EMPTY: return "SMB_STATUS_PIPE_EMPTY";
        case SMB_STATUS_PIPE_NOT_AVAILABLE: return "SMB_STATUS_PIPE_NOT_AVAILABLE";
        case SMB_STATUS_PORT_CONNECTION_REFUSED: return "SMB_STATUS_PORT_CONNECTION_REFUSED";
        case SMB_STATUS_PORT_DISCONNECTED: return "SMB_STATUS_PORT_DISCONNECTED";
        case SMB_STATUS_PRINT_CANCELLED: return "SMB_STATUS_PRINT_CANCELLED";
        case SMB_STATUS_PRINT_QUEUE_FULL: return "SMB_STATUS_PRINT_QUEUE_FULL";
        case SMB_STATUS_PRIVILEGE_NOT_HELD: return "SMB_STATUS_PRIVILEGE_NOT_HELD";
        case SMB_STATUS_PROCESS_IS_TERMINATING: return "SMB_STATUS_PROCESS_IS_TERMINATING";
        case SMB_STATUS_RANGE_NOT_LOCKED: return "SMB_STATUS_RANGE_NOT_LOCKED";
        case SMB_STATUS_REDIRECTOR_NOT_STARTED: return "SMB_STATUS_REDIRECTOR_NOT_STARTED";
        case SMB_STATUS_REQUEST_NOT_ACCEPTED: return "SMB_STATUS_REQUEST_NOT_ACCEPTED";
        case SMB_STATUS_SECTION_TOO_BIG: return "SMB_STATUS_SECTION_TOO_BIG";
        case SMB_STATUS_SHARING_VIOLATION: return "SMB_STATUS_SHARING_VIOLATION";
        case SMB_STATUS_SMB_BAD_COMMAND: return "SMB_STATUS_SMB_BAD_COMMAND";
        case SMB_STATUS_SMB_BAD_FID: return "SMB_STATUS_SMB_BAD_FID";
        case SMB_STATUS_SMB_BAD_TID: return "SMB_STATUS_SMB_BAD_TID";
        case SMB_STATUS_SMB_BAD_UID: return "SMB_STATUS_SMB_BAD_UID";
        case SMB_STATUS_SMB_CONTINUE_MPX: return "SMB_STATUS_SMB_CONTINUE_MPX";
        case SMB_STATUS_SMB_NO_SUPPORT: return "SMB_STATUS_SMB_NO_SUPPORT";
        case SMB_STATUS_SMB_USE_MPX: return "SMB_STATUS_SMB_USE_MPX";
        case SMB_STATUS_SMB_USE_STANDARD: return "SMB_STATUS_SMB_USE_STANDARD";
        case SMB_STATUS_THREAD_IS_TERMINATING: return "SMB_STATUS_THREAD_IS_TERMINATING";
        case SMB_STATUS_TOO_MANY_OPENED_FILES: return "SMB_STATUS_TOO_MANY_OPENED_FILES";
        case SMB_STATUS_TOO_MANY_PAGING_FILES: return "SMB_STATUS_TOO_MANY_PAGING_FILES";
        case SMB_STATUS_TOO_MANY_SESSIONS: return "SMB_STATUS_TOO_MANY_SESSIONS";
        case SMB_STATUS_UNEXPECTED_NETWORK_ERROR: return "SMB_STATUS_UNEXPECTED_NETWORK_ERROR";
        case SMB_STATUS_UNSUCCESSFUL: return "SMB_STATUS_UNSUCCESSFUL";
        case SMB_STATUS_WRONG_PASSWORD: return "SMB_STATUS_WRONG_PASSWORD";
        case SMB_STATUS_WRONG_VOLUME: return "SMB_STATUS_WRONG_VOLUME";

        case NT_STATUS_ABANDONED: return "NT_STATUS_ABANDONED";
        case NT_STATUS_USER_APC: return "NT_STATUS_USER_APC";
        case NT_STATUS_KERNEL_APC: return "NT_STATUS_KERNEL_APC";
        case NT_STATUS_ALERTED: return "NT_STATUS_ALERTED";
        case NT_STATUS_TIMEOUT: return "NT_STATUS_TIMEOUT";
        case NT_STATUS_PENDING: return "NT_STATUS_PENDING";
        case NT_STATUS_REPARSE: return "NT_STATUS_REPARSE";
        case NT_STATUS_MORE_ENTRIES: return "NT_STATUS_MORE_ENTRIES";
        case NT_STATUS_NOT_ALL_ASSIGNED: return "NT_STATUS_NOT_ALL_ASSIGNED";
        case NT_STATUS_SOME_NOT_MAPPED: return "NT_STATUS_SOME_NOT_MAPPED";
        case NT_STATUS_OPLOCK_BREAK_IN_PROGRESS: return "NT_STATUS_OPLOCK_BREAK_IN_PROGRESS";
        case NT_STATUS_VOLUME_MOUNTED: return "NT_STATUS_VOLUME_MOUNTED";
        case NT_STATUS_RXACT_COMMITTED: return "NT_STATUS_RXACT_COMMITTED";
        case NT_STATUS_NOTIFY_CLEANUP: return "NT_STATUS_NOTIFY_CLEANUP";
        case NT_STATUS_NO_QUOTAS_FOR_ACCOUNT: return "NT_STATUS_NO_QUOTAS_FOR_ACCOUNT";
        case NT_STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED: return "NT_STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED";
        case NT_STATUS_PAGE_FAULT_TRANSITION: return "NT_STATUS_PAGE_FAULT_TRANSITION";
        case NT_STATUS_PAGE_FAULT_DEMAND_ZERO: return "NT_STATUS_PAGE_FAULT_DEMAND_ZERO";
        case NT_STATUS_PAGE_FAULT_COPY_ON_WRITE: return "NT_STATUS_PAGE_FAULT_COPY_ON_WRITE";
        case NT_STATUS_PAGE_FAULT_GUARD_PAGE: return "NT_STATUS_PAGE_FAULT_GUARD_PAGE";
        case NT_STATUS_PAGE_FAULT_PAGING_FILE: return "NT_STATUS_PAGE_FAULT_PAGING_FILE";
        case NT_STATUS_CACHE_PAGE_LOCKED: return "NT_STATUS_CACHE_PAGE_LOCKED";
        case NT_STATUS_CRASH_DUMP: return "NT_STATUS_CRASH_DUMP";
        case NT_STATUS_BUFFER_ALL_ZEROS: return "NT_STATUS_BUFFER_ALL_ZEROS";
        case NT_STATUS_REPARSE_OBJECT: return "NT_STATUS_REPARSE_OBJECT";
        case NT_STATUS_RESOURCE_REQUIREMENTS_CHANGED: return "NT_STATUS_RESOURCE_REQUIREMENTS_CHANGED";
        case NT_STATUS_TRANSLATION_COMPLETE: return "NT_STATUS_TRANSLATION_COMPLETE";
        case NT_STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY: return "NT_STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY";
        case NT_STATUS_NOTHING_TO_TERMINATE: return "NT_STATUS_NOTHING_TO_TERMINATE";
        case NT_STATUS_PROCESS_NOT_IN_JOB: return "NT_STATUS_PROCESS_NOT_IN_JOB";
        case NT_STATUS_PROCESS_IN_JOB: return "NT_STATUS_PROCESS_IN_JOB";
        case NT_STATUS_OBJECT_NAME_EXISTS: return "NT_STATUS_OBJECT_NAME_EXISTS";
        case NT_STATUS_THREAD_WAS_SUSPENDED: return "NT_STATUS_THREAD_WAS_SUSPENDED";
        case NT_STATUS_WORKING_SET_LIMIT_RANGE: return "NT_STATUS_WORKING_SET_LIMIT_RANGE";
        case NT_STATUS_IMAGE_NOT_AT_BASE: return "NT_STATUS_IMAGE_NOT_AT_BASE";
        case NT_STATUS_RXACT_STATE_CREATED: return "NT_STATUS_RXACT_STATE_CREATED";
        case NT_STATUS_SEGMENT_NOTIFICATION: return "NT_STATUS_SEGMENT_NOTIFICATION";
        case NT_STATUS_LOCAL_USER_SESSION_KEY: return "NT_STATUS_LOCAL_USER_SESSION_KEY";
        case NT_STATUS_BAD_CURRENT_DIRECTORY: return "NT_STATUS_BAD_CURRENT_DIRECTORY";
        case NT_STATUS_SERIAL_MORE_WRITES: return "NT_STATUS_SERIAL_MORE_WRITES";
        case NT_STATUS_REGISTRY_RECOVERED: return "NT_STATUS_REGISTRY_RECOVERED";
        case NT_STATUS_FT_READ_RECOVERY_FROM_BACKUP: return "NT_STATUS_FT_READ_RECOVERY_FROM_BACKUP";
        case NT_STATUS_FT_WRITE_RECOVERY: return "NT_STATUS_FT_WRITE_RECOVERY";
        case NT_STATUS_SERIAL_COUNTER_TIMEOUT: return "NT_STATUS_SERIAL_COUNTER_TIMEOUT";
        case NT_STATUS_NULL_LM_PASSWORD: return "NT_STATUS_NULL_LM_PASSWORD";
        case NT_STATUS_IMAGE_MACHINE_TYPE_MISMATCH: return "NT_STATUS_IMAGE_MACHINE_TYPE_MISMATCH";
        case NT_STATUS_RECEIVE_PARTIAL: return "NT_STATUS_RECEIVE_PARTIAL";
        case NT_STATUS_RECEIVE_EXPEDITED: return "NT_STATUS_RECEIVE_EXPEDITED";
        case NT_STATUS_RECEIVE_PARTIAL_EXPEDITED: return "NT_STATUS_RECEIVE_PARTIAL_EXPEDITED";
        case NT_STATUS_EVENT_DONE: return "NT_STATUS_EVENT_DONE";
        case NT_STATUS_EVENT_PENDING: return "NT_STATUS_EVENT_PENDING";
        case NT_STATUS_CHECKING_FILE_SYSTEM: return "NT_STATUS_CHECKING_FILE_SYSTEM";
        case NT_STATUS_FATAL_APP_EXIT: return "NT_STATUS_FATAL_APP_EXIT";
        case NT_STATUS_PREDEFINED_HANDLE: return "NT_STATUS_PREDEFINED_HANDLE";
        case NT_STATUS_WAS_UNLOCKED: return "NT_STATUS_WAS_UNLOCKED";
        case NT_STATUS_SERVICE_NOTIFICATION: return "NT_STATUS_SERVICE_NOTIFICATION";
        case NT_STATUS_WAS_LOCKED: return "NT_STATUS_WAS_LOCKED";
        case NT_STATUS_LOG_HARD_ERROR: return "NT_STATUS_LOG_HARD_ERROR";
        case NT_STATUS_ALREADY_WIN32: return "NT_STATUS_ALREADY_WIN32";
        case NT_STATUS_WX86_UNSIMULATE: return "NT_STATUS_WX86_UNSIMULATE";
        case NT_STATUS_WX86_CONTINUE: return "NT_STATUS_WX86_CONTINUE";
        case NT_STATUS_WX86_SINGLE_STEP: return "NT_STATUS_WX86_SINGLE_STEP";
        case NT_STATUS_WX86_BREAKPOINT: return "NT_STATUS_WX86_BREAKPOINT";
        case NT_STATUS_WX86_EXCEPTION_CONTINUE: return "NT_STATUS_WX86_EXCEPTION_CONTINUE";
        case NT_STATUS_WX86_EXCEPTION_LASTCHANCE: return "NT_STATUS_WX86_EXCEPTION_LASTCHANCE";
        case NT_STATUS_WX86_EXCEPTION_CHAIN: return "NT_STATUS_WX86_EXCEPTION_CHAIN";
        case NT_STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE: return "NT_STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE";
        case NT_STATUS_NO_YIELD_PERFORMED: return "NT_STATUS_NO_YIELD_PERFORMED";
        case NT_STATUS_TIMER_RESUME_IGNORED: return "NT_STATUS_TIMER_RESUME_IGNORED";
        case NT_STATUS_ARBITRATION_UNHANDLED: return "NT_STATUS_ARBITRATION_UNHANDLED";
        case NT_STATUS_CARDBUS_NOT_SUPPORTED: return "NT_STATUS_CARDBUS_NOT_SUPPORTED";
        case NT_STATUS_WX86_CREATEWX86TIB: return "NT_STATUS_WX86_CREATEWX86TIB";
        case NT_STATUS_MP_PROCESSOR_MISMATCH: return "NT_STATUS_MP_PROCESSOR_MISMATCH";
        case NT_STATUS_HIBERNATED: return "NT_STATUS_HIBERNATED";
        case NT_STATUS_RESUME_HIBERNATION: return "NT_STATUS_RESUME_HIBERNATION";
        case NT_STATUS_GUARD_PAGE_VIOLATION: return "NT_STATUS_GUARD_PAGE_VIOLATION";
        case NT_STATUS_DATATYPE_MISALIGNMENT: return "NT_STATUS_DATATYPE_MISALIGNMENT";
        case NT_STATUS_BREAKPOINT: return "NT_STATUS_BREAKPOINT";
        case NT_STATUS_SINGLE_STEP: return "NT_STATUS_SINGLE_STEP";
        case NT_STATUS_WAKE_SYSTEM_DEBUGGER: return "NT_STATUS_WAKE_SYSTEM_DEBUGGER";
        case NT_STATUS_HANDLES_CLOSED: return "NT_STATUS_HANDLES_CLOSED";
        case NT_STATUS_NO_INHERITANCE: return "NT_STATUS_NO_INHERITANCE";
        case NT_STATUS_GUID_SUBSTITUTION_MADE: return "NT_STATUS_GUID_SUBSTITUTION_MADE";
        case NT_STATUS_PARTIAL_COPY: return "NT_STATUS_PARTIAL_COPY";
        case NT_STATUS_DEVICE_POWERED_OFF: return "NT_STATUS_DEVICE_POWERED_OFF";
        case NT_STATUS_DEVICE_OFF_LINE: return "NT_STATUS_DEVICE_OFF_LINE";
        case NT_STATUS_DEVICE_BUSY: return "NT_STATUS_DEVICE_BUSY";
        case NT_STATUS_NO_MORE_EAS: return "NT_STATUS_NO_MORE_EAS";
        case NT_STATUS_INVALID_EA_NAME: return "NT_STATUS_INVALID_EA_NAME";
        case NT_STATUS_EA_LIST_INCONSISTENT: return "NT_STATUS_EA_LIST_INCONSISTENT";
        case NT_STATUS_INVALID_EA_FLAG: return "NT_STATUS_INVALID_EA_FLAG";
        case NT_STATUS_VERIFY_REQUIRED: return "NT_STATUS_VERIFY_REQUIRED";
        case NT_STATUS_EXTRANEOUS_INFORMATION: return "NT_STATUS_EXTRANEOUS_INFORMATION";
        case NT_STATUS_RXACT_COMMIT_NECESSARY: return "NT_STATUS_RXACT_COMMIT_NECESSARY";
        case NT_STATUS_NO_MORE_ENTRIES: return "NT_STATUS_NO_MORE_ENTRIES";
        case NT_STATUS_FILEMARK_DETECTED: return "NT_STATUS_FILEMARK_DETECTED";
        case NT_STATUS_MEDIA_CHANGED: return "NT_STATUS_MEDIA_CHANGED";
        case NT_STATUS_BUS_RESET: return "NT_STATUS_BUS_RESET";
        case NT_STATUS_END_OF_MEDIA: return "NT_STATUS_END_OF_MEDIA";
        case NT_STATUS_BEGINNING_OF_MEDIA: return "NT_STATUS_BEGINNING_OF_MEDIA";
        case NT_STATUS_MEDIA_CHECK: return "NT_STATUS_MEDIA_CHECK";
        case NT_STATUS_SETMARK_DETECTED: return "NT_STATUS_SETMARK_DETECTED";
        case NT_STATUS_NO_DATA_DETECTED: return "NT_STATUS_NO_DATA_DETECTED";
        case NT_STATUS_REDIRECTOR_HAS_OPEN_HANDLES: return "NT_STATUS_REDIRECTOR_HAS_OPEN_HANDLES";
        case NT_STATUS_SERVER_HAS_OPEN_HANDLES: return "NT_STATUS_SERVER_HAS_OPEN_HANDLES";
        case NT_STATUS_ALREADY_DISCONNECTED: return "NT_STATUS_ALREADY_DISCONNECTED";
        case NT_STATUS_LONGJUMP: return "NT_STATUS_LONGJUMP";
        case NT_STATUS_CLEANER_CARTRIDGE_INSTALLED: return "NT_STATUS_CLEANER_CARTRIDGE_INSTALLED";
        case NT_STATUS_PLUGPLAY_QUERY_VETOED: return "NT_STATUS_PLUGPLAY_QUERY_VETOED";
        case NT_STATUS_UNWIND_CONSOLIDATE: return "NT_STATUS_UNWIND_CONSOLIDATE";
        case NT_STATUS_INFO_LENGTH_MISMATCH: return "NT_STATUS_INFO_LENGTH_MISMATCH";
        case NT_STATUS_ACCESS_VIOLATION: return "NT_STATUS_ACCESS_VIOLATION";
        case NT_STATUS_IN_PAGE_ERROR: return "NT_STATUS_IN_PAGE_ERROR";
        case NT_STATUS_PAGEFILE_QUOTA: return "NT_STATUS_PAGEFILE_QUOTA";
        case NT_STATUS_BAD_INITIAL_STACK: return "NT_STATUS_BAD_INITIAL_STACK";
        case NT_STATUS_BAD_INITIAL_PC: return "NT_STATUS_BAD_INITIAL_PC";
        case NT_STATUS_INVALID_CID: return "NT_STATUS_INVALID_CID";
        case NT_STATUS_TIMER_NOT_CANCELED: return "NT_STATUS_TIMER_NOT_CANCELED";
        case NT_STATUS_UNRECOGNIZED_MEDIA: return "NT_STATUS_UNRECOGNIZED_MEDIA";
        case NT_STATUS_NO_MEMORY: return "NT_STATUS_NO_MEMORY";
        case NT_STATUS_CONFLICTING_ADDRESSES: return "NT_STATUS_CONFLICTING_ADDRESSES";
        case NT_STATUS_NOT_MAPPED_VIEW: return "NT_STATUS_NOT_MAPPED_VIEW";
        case NT_STATUS_UNABLE_TO_FREE_VM: return "NT_STATUS_UNABLE_TO_FREE_VM";
        case NT_STATUS_UNABLE_TO_DELETE_SECTION: return "NT_STATUS_UNABLE_TO_DELETE_SECTION";
        case NT_STATUS_INVALID_SYSTEM_SERVICE: return "NT_STATUS_INVALID_SYSTEM_SERVICE";
        case NT_STATUS_ILLEGAL_INSTRUCTION: return "NT_STATUS_ILLEGAL_INSTRUCTION";
        case NT_STATUS_INVALID_FILE_FOR_SECTION: return "NT_STATUS_INVALID_FILE_FOR_SECTION";
        case NT_STATUS_BUFFER_TOO_SMALL: return "NT_STATUS_BUFFER_TOO_SMALL";
        case NT_STATUS_NONCONTINUABLE_EXCEPTION: return "NT_STATUS_NONCONTINUABLE_EXCEPTION";
        case NT_STATUS_INVALID_DISPOSITION: return "NT_STATUS_INVALID_DISPOSITION";
        case NT_STATUS_UNWIND: return "NT_STATUS_UNWIND";
        case NT_STATUS_BAD_STACK: return "NT_STATUS_BAD_STACK";
        case NT_STATUS_INVALID_UNWIND_TARGET: return "NT_STATUS_INVALID_UNWIND_TARGET";
        case NT_STATUS_NOT_LOCKED: return "NT_STATUS_NOT_LOCKED";
        case NT_STATUS_PARITY_ERROR: return "NT_STATUS_PARITY_ERROR";
        case NT_STATUS_UNABLE_TO_DECOMMIT_VM: return "NT_STATUS_UNABLE_TO_DECOMMIT_VM";
        case NT_STATUS_NOT_COMMITTED: return "NT_STATUS_NOT_COMMITTED";
        case NT_STATUS_INVALID_PORT_ATTRIBUTES: return "NT_STATUS_INVALID_PORT_ATTRIBUTES";
        case NT_STATUS_PORT_MESSAGE_TOO_LONG: return "NT_STATUS_PORT_MESSAGE_TOO_LONG";
        case NT_STATUS_INVALID_PARAMETER_MIX: return "NT_STATUS_INVALID_PARAMETER_MIX";
        case NT_STATUS_INVALID_QUOTA_LOWER: return "NT_STATUS_INVALID_QUOTA_LOWER";
        case NT_STATUS_OBJECT_NAME_INVALID: return "NT_STATUS_OBJECT_NAME_INVALID";
        case NT_STATUS_DEVICE_ALREADY_ATTACHED: return "NT_STATUS_DEVICE_ALREADY_ATTACHED";
        case NT_STATUS_DATA_OVERRUN: return "NT_STATUS_DATA_OVERRUN";
        case NT_STATUS_DATA_LATE_ERROR: return "NT_STATUS_DATA_LATE_ERROR";
        case NT_STATUS_QUOTA_EXCEEDED: return "NT_STATUS_QUOTA_EXCEEDED";
        case NT_STATUS_INVALID_PAGE_PROTECTION: return "NT_STATUS_INVALID_PAGE_PROTECTION";
        case NT_STATUS_MUTANT_NOT_OWNED: return "NT_STATUS_MUTANT_NOT_OWNED";
        case NT_STATUS_SEMAPHORE_LIMIT_EXCEEDED: return "NT_STATUS_SEMAPHORE_LIMIT_EXCEEDED";
        case NT_STATUS_PORT_ALREADY_SET: return "NT_STATUS_PORT_ALREADY_SET";
        case NT_STATUS_SECTION_NOT_IMAGE: return "NT_STATUS_SECTION_NOT_IMAGE";
        case NT_STATUS_SUSPEND_COUNT_EXCEEDED: return "NT_STATUS_SUSPEND_COUNT_EXCEEDED";
        case NT_STATUS_BAD_WORKING_SET_LIMIT: return "NT_STATUS_BAD_WORKING_SET_LIMIT";
        case NT_STATUS_INCOMPATIBLE_FILE_MAP: return "NT_STATUS_INCOMPATIBLE_FILE_MAP";
        case NT_STATUS_SECTION_PROTECTION: return "NT_STATUS_SECTION_PROTECTION";
        case NT_STATUS_NONEXISTENT_EA_ENTRY: return "NT_STATUS_NONEXISTENT_EA_ENTRY";
        case NT_STATUS_NO_EAS_ON_FILE: return "NT_STATUS_NO_EAS_ON_FILE";
        case NT_STATUS_EA_CORRUPT_ERROR: return "NT_STATUS_EA_CORRUPT_ERROR";
        case NT_STATUS_CTL_FILE_NOT_SUPPORTED: return "NT_STATUS_CTL_FILE_NOT_SUPPORTED";
        case NT_STATUS_UNKNOWN_REVISION: return "NT_STATUS_UNKNOWN_REVISION";
        case NT_STATUS_REVISION_MISMATCH: return "NT_STATUS_REVISION_MISMATCH";
        case NT_STATUS_INVALID_OWNER: return "NT_STATUS_INVALID_OWNER";
        case NT_STATUS_INVALID_PRIMARY_GROUP: return "NT_STATUS_INVALID_PRIMARY_GROUP";
        case NT_STATUS_NO_IMPERSONATION_TOKEN: return "NT_STATUS_NO_IMPERSONATION_TOKEN";
        case NT_STATUS_CANT_DISABLE_MANDATORY: return "NT_STATUS_CANT_DISABLE_MANDATORY";
        case NT_STATUS_NO_LOGON_SERVERS: return "NT_STATUS_NO_LOGON_SERVERS";
        case NT_STATUS_NO_SUCH_LOGON_SESSION: return "NT_STATUS_NO_SUCH_LOGON_SESSION";
        case NT_STATUS_NO_SUCH_PRIVILEGE: return "NT_STATUS_NO_SUCH_PRIVILEGE";
        case NT_STATUS_INVALID_ACCOUNT_NAME: return "NT_STATUS_INVALID_ACCOUNT_NAME";
        case NT_STATUS_USER_EXISTS: return "NT_STATUS_USER_EXISTS";
        case NT_STATUS_NO_SUCH_USER: return "NT_STATUS_NO_SUCH_USER";
        case NT_STATUS_GROUP_EXISTS: return "NT_STATUS_GROUP_EXISTS";
        case NT_STATUS_NO_SUCH_GROUP: return "NT_STATUS_NO_SUCH_GROUP";
        case NT_STATUS_MEMBER_IN_GROUP: return "NT_STATUS_MEMBER_IN_GROUP";
        case NT_STATUS_MEMBER_NOT_IN_GROUP: return "NT_STATUS_MEMBER_NOT_IN_GROUP";
        case NT_STATUS_LAST_ADMIN: return "NT_STATUS_LAST_ADMIN";
        case NT_STATUS_ILL_FORMED_PASSWORD: return "NT_STATUS_ILL_FORMED_PASSWORD";
        case NT_STATUS_PASSWORD_RESTRICTION: return "NT_STATUS_PASSWORD_RESTRICTION";
        case NT_STATUS_ACCOUNT_RESTRICTION: return "NT_STATUS_ACCOUNT_RESTRICTION";
        case NT_STATUS_TOO_MANY_LUIDS_REQUESTED: return "NT_STATUS_TOO_MANY_LUIDS_REQUESTED";
        case NT_STATUS_LUIDS_EXHAUSTED: return "NT_STATUS_LUIDS_EXHAUSTED";
        case NT_STATUS_INVALID_SUB_AUTHORITY: return "NT_STATUS_INVALID_SUB_AUTHORITY";
        case NT_STATUS_INVALID_ACL: return "NT_STATUS_INVALID_ACL";
        case NT_STATUS_INVALID_SID: return "NT_STATUS_INVALID_SID";
        case NT_STATUS_INVALID_SECURITY_DESCR: return "NT_STATUS_INVALID_SECURITY_DESCR";
        case NT_STATUS_PROCEDURE_NOT_FOUND: return "NT_STATUS_PROCEDURE_NOT_FOUND";
        case NT_STATUS_INVALID_IMAGE_FORMAT: return "NT_STATUS_INVALID_IMAGE_FORMAT";
        case NT_STATUS_NO_TOKEN: return "NT_STATUS_NO_TOKEN";
        case NT_STATUS_BAD_INHERITANCE_ACL: return "NT_STATUS_BAD_INHERITANCE_ACL";
        case NT_STATUS_SERVER_DISABLED: return "NT_STATUS_SERVER_DISABLED";
        case NT_STATUS_SERVER_NOT_DISABLED: return "NT_STATUS_SERVER_NOT_DISABLED";
        case NT_STATUS_TOO_MANY_GUIDS_REQUESTED: return "NT_STATUS_TOO_MANY_GUIDS_REQUESTED";
        case NT_STATUS_GUIDS_EXHAUSTED: return "NT_STATUS_GUIDS_EXHAUSTED";
        case NT_STATUS_INVALID_ID_AUTHORITY: return "NT_STATUS_INVALID_ID_AUTHORITY";
        case NT_STATUS_AGENTS_EXHAUSTED: return "NT_STATUS_AGENTS_EXHAUSTED";
        case NT_STATUS_INVALID_VOLUME_LABEL: return "NT_STATUS_INVALID_VOLUME_LABEL";
        case NT_STATUS_SECTION_NOT_EXTENDED: return "NT_STATUS_SECTION_NOT_EXTENDED";
        case NT_STATUS_NOT_MAPPED_DATA: return "NT_STATUS_NOT_MAPPED_DATA";
        case NT_STATUS_RESOURCE_DATA_NOT_FOUND: return "NT_STATUS_RESOURCE_DATA_NOT_FOUND";
        case NT_STATUS_RESOURCE_TYPE_NOT_FOUND: return "NT_STATUS_RESOURCE_TYPE_NOT_FOUND";
        case NT_STATUS_RESOURCE_NAME_NOT_FOUND: return "NT_STATUS_RESOURCE_NAME_NOT_FOUND";
        case NT_STATUS_ARRAY_BOUNDS_EXCEEDED: return "NT_STATUS_ARRAY_BOUNDS_EXCEEDED";
        case NT_STATUS_FLOAT_DENORMAL_OPERAND: return "NT_STATUS_FLOAT_DENORMAL_OPERAND";
        case NT_STATUS_FLOAT_DIVIDE_BY_ZERO: return "NT_STATUS_FLOAT_DIVIDE_BY_ZERO";
        case NT_STATUS_FLOAT_INEXACT_RESULT: return "NT_STATUS_FLOAT_INEXACT_RESULT";
        case NT_STATUS_FLOAT_INVALID_OPERATION: return "NT_STATUS_FLOAT_INVALID_OPERATION";
        case NT_STATUS_FLOAT_OVERFLOW: return "NT_STATUS_FLOAT_OVERFLOW";
        case NT_STATUS_FLOAT_STACK_CHECK: return "NT_STATUS_FLOAT_STACK_CHECK";
        case NT_STATUS_FLOAT_UNDERFLOW: return "NT_STATUS_FLOAT_UNDERFLOW";
        case NT_STATUS_INTEGER_DIVIDE_BY_ZERO: return "NT_STATUS_INTEGER_DIVIDE_BY_ZERO";
        case NT_STATUS_INTEGER_OVERFLOW: return "NT_STATUS_INTEGER_OVERFLOW";
        case NT_STATUS_PRIVILEGED_INSTRUCTION: return "NT_STATUS_PRIVILEGED_INSTRUCTION";
        case NT_STATUS_FILE_INVALID: return "NT_STATUS_FILE_INVALID";
        case NT_STATUS_ALLOTTED_SPACE_EXCEEDED: return "NT_STATUS_ALLOTTED_SPACE_EXCEEDED";
        case NT_STATUS_INSUFFICIENT_RESOURCES: return "NT_STATUS_INSUFFICIENT_RESOURCES";
        case NT_STATUS_DEVICE_NOT_CONNECTED: return "NT_STATUS_DEVICE_NOT_CONNECTED";
        case NT_STATUS_DEVICE_POWER_FAILURE: return "NT_STATUS_DEVICE_POWER_FAILURE";
        case NT_STATUS_FREE_VM_NOT_AT_BASE: return "NT_STATUS_FREE_VM_NOT_AT_BASE";
        case NT_STATUS_MEMORY_NOT_ALLOCATED: return "NT_STATUS_MEMORY_NOT_ALLOCATED";
        case NT_STATUS_WORKING_SET_QUOTA: return "NT_STATUS_WORKING_SET_QUOTA";
        case NT_STATUS_DEVICE_NOT_READY: return "NT_STATUS_DEVICE_NOT_READY";
        case NT_STATUS_INVALID_GROUP_ATTRIBUTES: return "NT_STATUS_INVALID_GROUP_ATTRIBUTES";
        case NT_STATUS_BAD_IMPERSONATION_LEVEL: return "NT_STATUS_BAD_IMPERSONATION_LEVEL";
        case NT_STATUS_CANT_OPEN_ANONYMOUS: return "NT_STATUS_CANT_OPEN_ANONYMOUS";
        case NT_STATUS_BAD_VALIDATION_CLASS: return "NT_STATUS_BAD_VALIDATION_CLASS";
        case NT_STATUS_BAD_TOKEN_TYPE: return "NT_STATUS_BAD_TOKEN_TYPE";
        case NT_STATUS_BAD_MASTER_BOOT_RECORD: return "NT_STATUS_BAD_MASTER_BOOT_RECORD";
        case NT_STATUS_INSTRUCTION_MISALIGNMENT: return "NT_STATUS_INSTRUCTION_MISALIGNMENT";
        case NT_STATUS_PIPE_CONNECTED: return "NT_STATUS_PIPE_CONNECTED";
        case NT_STATUS_PIPE_LISTENING: return "NT_STATUS_PIPE_LISTENING";
        case NT_STATUS_FILE_FORCED_CLOSED: return "NT_STATUS_FILE_FORCED_CLOSED";
        case NT_STATUS_PROFILING_NOT_STARTED: return "NT_STATUS_PROFILING_NOT_STARTED";
        case NT_STATUS_PROFILING_NOT_STOPPED: return "NT_STATUS_PROFILING_NOT_STOPPED";
        case NT_STATUS_COULD_NOT_INTERPRET: return "NT_STATUS_COULD_NOT_INTERPRET";
        case NT_STATUS_REMOTE_NOT_LISTENING: return "NT_STATUS_REMOTE_NOT_LISTENING";
        case NT_STATUS_DUPLICATE_NAME: return "NT_STATUS_DUPLICATE_NAME";
        case NT_STATUS_BAD_NETWORK_PATH: return "NT_STATUS_BAD_NETWORK_PATH";
        case NT_STATUS_NETWORK_BUSY: return "NT_STATUS_NETWORK_BUSY";
        case NT_STATUS_DEVICE_DOES_NOT_EXIST: return "NT_STATUS_DEVICE_DOES_NOT_EXIST";
        case NT_STATUS_TOO_MANY_COMMANDS: return "NT_STATUS_TOO_MANY_COMMANDS";
        case NT_STATUS_ADAPTER_HARDWARE_ERROR: return "NT_STATUS_ADAPTER_HARDWARE_ERROR";
        case NT_STATUS_INVALID_NETWORK_RESPONSE: return "NT_STATUS_INVALID_NETWORK_RESPONSE";
        case NT_STATUS_BAD_REMOTE_ADAPTER: return "NT_STATUS_BAD_REMOTE_ADAPTER";
        case NT_STATUS_TOO_MANY_NAMES: return "NT_STATUS_TOO_MANY_NAMES";
        case NT_STATUS_SHARING_PAUSED: return "NT_STATUS_SHARING_PAUSED";
        case NT_STATUS_REDIRECTOR_PAUSED: return "NT_STATUS_REDIRECTOR_PAUSED";
        case NT_STATUS_NET_WRITE_FAULT: return "NT_STATUS_NET_WRITE_FAULT";
        case NT_STATUS_PROFILING_AT_LIMIT: return "NT_STATUS_PROFILING_AT_LIMIT";
        case NT_STATUS_VIRTUAL_CIRCUIT_CLOSED: return "NT_STATUS_VIRTUAL_CIRCUIT_CLOSED";
        case NT_STATUS_NO_SECURITY_ON_OBJECT: return "NT_STATUS_NO_SECURITY_ON_OBJECT";
        case NT_STATUS_CANT_WAIT: return "NT_STATUS_CANT_WAIT";
        case NT_STATUS_CANT_ACCESS_DOMAIN_INFO: return "NT_STATUS_CANT_ACCESS_DOMAIN_INFO";
        case NT_STATUS_CANT_TERMINATE_SELF: return "NT_STATUS_CANT_TERMINATE_SELF";
        case NT_STATUS_INVALID_SERVER_STATE: return "NT_STATUS_INVALID_SERVER_STATE";
        case NT_STATUS_INVALID_DOMAIN_STATE: return "NT_STATUS_INVALID_DOMAIN_STATE";
        case NT_STATUS_INVALID_DOMAIN_ROLE: return "NT_STATUS_INVALID_DOMAIN_ROLE";
        case NT_STATUS_NO_SUCH_DOMAIN: return "NT_STATUS_NO_SUCH_DOMAIN";
        case NT_STATUS_DOMAIN_EXISTS: return "NT_STATUS_DOMAIN_EXISTS";
        case NT_STATUS_DOMAIN_LIMIT_EXCEEDED: return "NT_STATUS_DOMAIN_LIMIT_EXCEEDED";
        case NT_STATUS_OPLOCK_NOT_GRANTED: return "NT_STATUS_OPLOCK_NOT_GRANTED";
        case NT_STATUS_INVALID_OPLOCK_PROTOCOL: return "NT_STATUS_INVALID_OPLOCK_PROTOCOL";
        case NT_STATUS_INTERNAL_DB_CORRUPTION: return "NT_STATUS_INTERNAL_DB_CORRUPTION";
        case NT_STATUS_INTERNAL_ERROR: return "NT_STATUS_INTERNAL_ERROR";
        case NT_STATUS_GENERIC_NOT_MAPPED: return "NT_STATUS_GENERIC_NOT_MAPPED";
        case NT_STATUS_BAD_DESCRIPTOR_FORMAT: return "NT_STATUS_BAD_DESCRIPTOR_FORMAT";
        case NT_STATUS_INVALID_USER_BUFFER: return "NT_STATUS_INVALID_USER_BUFFER";
        case NT_STATUS_UNEXPECTED_IO_ERROR: return "NT_STATUS_UNEXPECTED_IO_ERROR";
        case NT_STATUS_UNEXPECTED_MM_CREATE_ERR: return "NT_STATUS_UNEXPECTED_MM_CREATE_ERR";
        case NT_STATUS_UNEXPECTED_MM_MAP_ERROR: return "NT_STATUS_UNEXPECTED_MM_MAP_ERROR";
        case NT_STATUS_UNEXPECTED_MM_EXTEND_ERR: return "NT_STATUS_UNEXPECTED_MM_EXTEND_ERR";
        case NT_STATUS_NOT_LOGON_PROCESS: return "NT_STATUS_NOT_LOGON_PROCESS";
        case NT_STATUS_LOGON_SESSION_EXISTS: return "NT_STATUS_LOGON_SESSION_EXISTS";
        case NT_STATUS_INVALID_PARAMETER_1: return "NT_STATUS_INVALID_PARAMETER_1";
        case NT_STATUS_INVALID_PARAMETER_2: return "NT_STATUS_INVALID_PARAMETER_2";
        case NT_STATUS_INVALID_PARAMETER_3: return "NT_STATUS_INVALID_PARAMETER_3";
        case NT_STATUS_INVALID_PARAMETER_4: return "NT_STATUS_INVALID_PARAMETER_4";
        case NT_STATUS_INVALID_PARAMETER_5: return "NT_STATUS_INVALID_PARAMETER_5";
        case NT_STATUS_INVALID_PARAMETER_6: return "NT_STATUS_INVALID_PARAMETER_6";
        case NT_STATUS_INVALID_PARAMETER_7: return "NT_STATUS_INVALID_PARAMETER_7";
        case NT_STATUS_INVALID_PARAMETER_8: return "NT_STATUS_INVALID_PARAMETER_8";
        case NT_STATUS_INVALID_PARAMETER_9: return "NT_STATUS_INVALID_PARAMETER_9";
        case NT_STATUS_INVALID_PARAMETER_10: return "NT_STATUS_INVALID_PARAMETER_10";
        case NT_STATUS_INVALID_PARAMETER_11: return "NT_STATUS_INVALID_PARAMETER_11";
        case NT_STATUS_INVALID_PARAMETER_12: return "NT_STATUS_INVALID_PARAMETER_12";
        case NT_STATUS_REDIRECTOR_STARTED: return "NT_STATUS_REDIRECTOR_STARTED";
        case NT_STATUS_STACK_OVERFLOW: return "NT_STATUS_STACK_OVERFLOW";
        case NT_STATUS_NO_SUCH_PACKAGE: return "NT_STATUS_NO_SUCH_PACKAGE";
        case NT_STATUS_BAD_FUNCTION_TABLE: return "NT_STATUS_BAD_FUNCTION_TABLE";
        case NT_STATUS_VARIABLE_NOT_FOUND: return "NT_STATUS_VARIABLE_NOT_FOUND";
        case NT_STATUS_FILE_CORRUPT_ERROR: return "NT_STATUS_FILE_CORRUPT_ERROR";
        case NT_STATUS_NOT_A_DIRECTORY: return "NT_STATUS_NOT_A_DIRECTORY";
        case NT_STATUS_BAD_LOGON_SESSION_STATE: return "NT_STATUS_BAD_LOGON_SESSION_STATE";
        case NT_STATUS_LOGON_SESSION_COLLISION: return "NT_STATUS_LOGON_SESSION_COLLISION";
        case NT_STATUS_NAME_TOO_LONG: return "NT_STATUS_NAME_TOO_LONG";
        case NT_STATUS_FILES_OPEN: return "NT_STATUS_FILES_OPEN";
        case NT_STATUS_CONNECTION_IN_USE: return "NT_STATUS_CONNECTION_IN_USE";
        case NT_STATUS_MESSAGE_NOT_FOUND: return "NT_STATUS_MESSAGE_NOT_FOUND";
        case NT_STATUS_INVALID_LOGON_TYPE: return "NT_STATUS_INVALID_LOGON_TYPE";
        case NT_STATUS_NO_GUID_TRANSLATION: return "NT_STATUS_NO_GUID_TRANSLATION";
        case NT_STATUS_CANNOT_IMPERSONATE: return "NT_STATUS_CANNOT_IMPERSONATE";
        case NT_STATUS_IMAGE_ALREADY_LOADED: return "NT_STATUS_IMAGE_ALREADY_LOADED";
        case NT_STATUS_ABIOS_NOT_PRESENT: return "NT_STATUS_ABIOS_NOT_PRESENT";
        case NT_STATUS_ABIOS_LID_NOT_EXIST: return "NT_STATUS_ABIOS_LID_NOT_EXIST";
        case NT_STATUS_ABIOS_LID_ALREADY_OWNED: return "NT_STATUS_ABIOS_LID_ALREADY_OWNED";
        case NT_STATUS_ABIOS_NOT_LID_OWNER: return "NT_STATUS_ABIOS_NOT_LID_OWNER";
        case NT_STATUS_ABIOS_INVALID_COMMAND: return "NT_STATUS_ABIOS_INVALID_COMMAND";
        case NT_STATUS_ABIOS_INVALID_LID: return "NT_STATUS_ABIOS_INVALID_LID";
        case NT_STATUS_ABIOS_SELECTOR_NOT_AVAILABLE: return "NT_STATUS_ABIOS_SELECTOR_NOT_AVAILABLE";
        case NT_STATUS_ABIOS_INVALID_SELECTOR: return "NT_STATUS_ABIOS_INVALID_SELECTOR";
        case NT_STATUS_NO_LDT: return "NT_STATUS_NO_LDT";
        case NT_STATUS_INVALID_LDT_SIZE: return "NT_STATUS_INVALID_LDT_SIZE";
        case NT_STATUS_INVALID_LDT_OFFSET: return "NT_STATUS_INVALID_LDT_OFFSET";
        case NT_STATUS_INVALID_LDT_DESCRIPTOR: return "NT_STATUS_INVALID_LDT_DESCRIPTOR";
        case NT_STATUS_INVALID_IMAGE_NE_FORMAT: return "NT_STATUS_INVALID_IMAGE_NE_FORMAT";
        case NT_STATUS_RXACT_INVALID_STATE: return "NT_STATUS_RXACT_INVALID_STATE";
        case NT_STATUS_RXACT_COMMIT_FAILURE: return "NT_STATUS_RXACT_COMMIT_FAILURE";
        case NT_STATUS_MAPPED_FILE_SIZE_ZERO: return "NT_STATUS_MAPPED_FILE_SIZE_ZERO";
        case NT_STATUS_CANCELLED: return "NT_STATUS_CANCELLED";
        case NT_STATUS_INVALID_COMPUTER_NAME: return "NT_STATUS_INVALID_COMPUTER_NAME";
        case NT_STATUS_SPECIAL_ACCOUNT: return "NT_STATUS_SPECIAL_ACCOUNT";
        case NT_STATUS_SPECIAL_GROUP: return "NT_STATUS_SPECIAL_GROUP";
        case NT_STATUS_SPECIAL_USER: return "NT_STATUS_SPECIAL_USER";
        case NT_STATUS_MEMBERS_PRIMARY_GROUP: return "NT_STATUS_MEMBERS_PRIMARY_GROUP";
        case NT_STATUS_TOO_MANY_THREADS: return "NT_STATUS_TOO_MANY_THREADS";
        case NT_STATUS_THREAD_NOT_IN_PROCESS: return "NT_STATUS_THREAD_NOT_IN_PROCESS";
        case NT_STATUS_TOKEN_ALREADY_IN_USE: return "NT_STATUS_TOKEN_ALREADY_IN_USE";
        case NT_STATUS_PAGEFILE_QUOTA_EXCEEDED: return "NT_STATUS_PAGEFILE_QUOTA_EXCEEDED";
        case NT_STATUS_COMMITMENT_LIMIT: return "NT_STATUS_COMMITMENT_LIMIT";
        case NT_STATUS_INVALID_IMAGE_LE_FORMAT: return "NT_STATUS_INVALID_IMAGE_LE_FORMAT";
        case NT_STATUS_INVALID_IMAGE_NOT_MZ: return "NT_STATUS_INVALID_IMAGE_NOT_MZ";
        case NT_STATUS_INVALID_IMAGE_PROTECT: return "NT_STATUS_INVALID_IMAGE_PROTECT";
        case NT_STATUS_INVALID_IMAGE_WIN_16: return "NT_STATUS_INVALID_IMAGE_WIN_16";
        case NT_STATUS_LOGON_SERVER_CONFLICT: return "NT_STATUS_LOGON_SERVER_CONFLICT";
        case NT_STATUS_TIME_DIFFERENCE_AT_DC: return "NT_STATUS_TIME_DIFFERENCE_AT_DC";
        case NT_STATUS_SYNCHRONIZATION_REQUIRED: return "NT_STATUS_SYNCHRONIZATION_REQUIRED";
        case NT_STATUS_DLL_NOT_FOUND: return "NT_STATUS_DLL_NOT_FOUND";
        case NT_STATUS_OPEN_FAILED: return "NT_STATUS_OPEN_FAILED";
        case NT_STATUS_IO_PRIVILEGE_FAILED: return "NT_STATUS_IO_PRIVILEGE_FAILED";
        case NT_STATUS_ORDINAL_NOT_FOUND: return "NT_STATUS_ORDINAL_NOT_FOUND";
        case NT_STATUS_ENTRYPOINT_NOT_FOUND: return "NT_STATUS_ENTRYPOINT_NOT_FOUND";
        case NT_STATUS_CONTROL_C_EXIT: return "NT_STATUS_CONTROL_C_EXIT";
        case NT_STATUS_LOCAL_DISCONNECT: return "NT_STATUS_LOCAL_DISCONNECT";
        case NT_STATUS_REMOTE_DISCONNECT: return "NT_STATUS_REMOTE_DISCONNECT";
        case NT_STATUS_REMOTE_RESOURCES: return "NT_STATUS_REMOTE_RESOURCES";
        case NT_STATUS_LINK_FAILED: return "NT_STATUS_LINK_FAILED";
        case NT_STATUS_LINK_TIMEOUT: return "NT_STATUS_LINK_TIMEOUT";
        case NT_STATUS_INVALID_CONNECTION: return "NT_STATUS_INVALID_CONNECTION";
        case NT_STATUS_INVALID_ADDRESS: return "NT_STATUS_INVALID_ADDRESS";
        case NT_STATUS_DLL_INIT_FAILED: return "NT_STATUS_DLL_INIT_FAILED";
        case NT_STATUS_MISSING_SYSTEMFILE: return "NT_STATUS_MISSING_SYSTEMFILE";
        case NT_STATUS_UNHANDLED_EXCEPTION: return "NT_STATUS_UNHANDLED_EXCEPTION";
        case NT_STATUS_APP_INIT_FAILURE: return "NT_STATUS_APP_INIT_FAILURE";
        case NT_STATUS_PAGEFILE_CREATE_FAILED: return "NT_STATUS_PAGEFILE_CREATE_FAILED";
        case NT_STATUS_NO_PAGEFILE: return "NT_STATUS_NO_PAGEFILE";
        case NT_STATUS_INVALID_LEVEL: return "NT_STATUS_INVALID_LEVEL";
        case NT_STATUS_WRONG_PASSWORD_CORE: return "NT_STATUS_WRONG_PASSWORD_CORE";
        case NT_STATUS_ILLEGAL_FLOAT_CONTEXT: return "NT_STATUS_ILLEGAL_FLOAT_CONTEXT";
        case NT_STATUS_PIPE_BROKEN: return "NT_STATUS_PIPE_BROKEN";
        case NT_STATUS_REGISTRY_CORRUPT: return "NT_STATUS_REGISTRY_CORRUPT";
        case NT_STATUS_REGISTRY_IO_FAILED: return "NT_STATUS_REGISTRY_IO_FAILED";
        case NT_STATUS_NO_EVENT_PAIR: return "NT_STATUS_NO_EVENT_PAIR";
        case NT_STATUS_UNRECOGNIZED_VOLUME: return "NT_STATUS_UNRECOGNIZED_VOLUME";
        case NT_STATUS_SERIAL_NO_DEVICE_INITED: return "NT_STATUS_SERIAL_NO_DEVICE_INITED";
        case NT_STATUS_NO_SUCH_ALIAS: return "NT_STATUS_NO_SUCH_ALIAS";
        case NT_STATUS_MEMBER_NOT_IN_ALIAS: return "NT_STATUS_MEMBER_NOT_IN_ALIAS";
        case NT_STATUS_MEMBER_IN_ALIAS: return "NT_STATUS_MEMBER_IN_ALIAS";
        case NT_STATUS_ALIAS_EXISTS: return "NT_STATUS_ALIAS_EXISTS";
        case NT_STATUS_LOGON_NOT_GRANTED: return "NT_STATUS_LOGON_NOT_GRANTED";
        case NT_STATUS_TOO_MANY_SECRETS: return "NT_STATUS_TOO_MANY_SECRETS";
        case NT_STATUS_SECRET_TOO_LONG: return "NT_STATUS_SECRET_TOO_LONG";
        case NT_STATUS_INTERNAL_DB_ERROR: return "NT_STATUS_INTERNAL_DB_ERROR";
        case NT_STATUS_FULLSCREEN_MODE: return "NT_STATUS_FULLSCREEN_MODE";
        case NT_STATUS_TOO_MANY_CONTEXT_IDS: return "NT_STATUS_TOO_MANY_CONTEXT_IDS";
        case NT_STATUS_LOGON_TYPE_NOT_GRANTED: return "NT_STATUS_LOGON_TYPE_NOT_GRANTED";
        case NT_STATUS_NOT_REGISTRY_FILE: return "NT_STATUS_NOT_REGISTRY_FILE";
        case NT_STATUS_NT_CROSS_ENCRYPTION_REQUIRED: return "NT_STATUS_NT_CROSS_ENCRYPTION_REQUIRED";
        case NT_STATUS_DOMAIN_CTRLR_CONFIG_ERROR: return "NT_STATUS_DOMAIN_CTRLR_CONFIG_ERROR";
        case NT_STATUS_FT_MISSING_MEMBER: return "NT_STATUS_FT_MISSING_MEMBER";
        case NT_STATUS_ILL_FORMED_SERVICE_ENTRY: return "NT_STATUS_ILL_FORMED_SERVICE_ENTRY";
        case NT_STATUS_ILLEGAL_CHARACTER: return "NT_STATUS_ILLEGAL_CHARACTER";
        case NT_STATUS_UNMAPPABLE_CHARACTER: return "NT_STATUS_UNMAPPABLE_CHARACTER";
        case NT_STATUS_UNDEFINED_CHARACTER: return "NT_STATUS_UNDEFINED_CHARACTER";
        case NT_STATUS_FLOPPY_VOLUME: return "NT_STATUS_FLOPPY_VOLUME";
        case NT_STATUS_FLOPPY_ID_MARK_NOT_FOUND: return "NT_STATUS_FLOPPY_ID_MARK_NOT_FOUND";
        case NT_STATUS_FLOPPY_WRONG_CYLINDER: return "NT_STATUS_FLOPPY_WRONG_CYLINDER";
        case NT_STATUS_FLOPPY_UNKNOWN_ERROR: return "NT_STATUS_FLOPPY_UNKNOWN_ERROR";
        case NT_STATUS_FLOPPY_BAD_REGISTERS: return "NT_STATUS_FLOPPY_BAD_REGISTERS";
        case NT_STATUS_DISK_RECALIBRATE_FAILED: return "NT_STATUS_DISK_RECALIBRATE_FAILED";
        case NT_STATUS_DISK_OPERATION_FAILED: return "NT_STATUS_DISK_OPERATION_FAILED";
        case NT_STATUS_DISK_RESET_FAILED: return "NT_STATUS_DISK_RESET_FAILED";
        case NT_STATUS_SHARED_IRQ_BUSY: return "NT_STATUS_SHARED_IRQ_BUSY";
        case NT_STATUS_FT_ORPHANING: return "NT_STATUS_FT_ORPHANING";
        case NT_STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT: return "NT_STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT";
        case NT_STATUS_PARTITION_FAILURE: return "NT_STATUS_PARTITION_FAILURE";
        case NT_STATUS_INVALID_BLOCK_LENGTH: return "NT_STATUS_INVALID_BLOCK_LENGTH";
        case NT_STATUS_DEVICE_NOT_PARTITIONED: return "NT_STATUS_DEVICE_NOT_PARTITIONED";
        case NT_STATUS_UNABLE_TO_LOCK_MEDIA: return "NT_STATUS_UNABLE_TO_LOCK_MEDIA";
        case NT_STATUS_UNABLE_TO_UNLOAD_MEDIA: return "NT_STATUS_UNABLE_TO_UNLOAD_MEDIA";
        case NT_STATUS_EOM_OVERFLOW: return "NT_STATUS_EOM_OVERFLOW";
        case NT_STATUS_NO_MEDIA: return "NT_STATUS_NO_MEDIA";
        case NT_STATUS_NO_SUCH_MEMBER: return "NT_STATUS_NO_SUCH_MEMBER";
        case NT_STATUS_INVALID_MEMBER: return "NT_STATUS_INVALID_MEMBER";
        case NT_STATUS_KEY_DELETED: return "NT_STATUS_KEY_DELETED";
        case NT_STATUS_NO_LOG_SPACE: return "NT_STATUS_NO_LOG_SPACE";
        case NT_STATUS_TOO_MANY_SIDS: return "NT_STATUS_TOO_MANY_SIDS";
        case NT_STATUS_LM_CROSS_ENCRYPTION_REQUIRED: return "NT_STATUS_LM_CROSS_ENCRYPTION_REQUIRED";
        case NT_STATUS_KEY_HAS_CHILDREN: return "NT_STATUS_KEY_HAS_CHILDREN";
        case NT_STATUS_CHILD_MUST_BE_VOLATILE: return "NT_STATUS_CHILD_MUST_BE_VOLATILE";
        case NT_STATUS_DEVICE_CONFIGURATION_ERROR: return "NT_STATUS_DEVICE_CONFIGURATION_ERROR";
        case NT_STATUS_DRIVER_INTERNAL_ERROR: return "NT_STATUS_DRIVER_INTERNAL_ERROR";
        case NT_STATUS_IO_DEVICE_ERROR: return "NT_STATUS_IO_DEVICE_ERROR";
        case NT_STATUS_DEVICE_PROTOCOL_ERROR: return "NT_STATUS_DEVICE_PROTOCOL_ERROR";
        case NT_STATUS_BACKUP_CONTROLLER: return "NT_STATUS_BACKUP_CONTROLLER";
        case NT_STATUS_LOG_FILE_FULL: return "NT_STATUS_LOG_FILE_FULL";
        case NT_STATUS_TOO_LATE: return "NT_STATUS_TOO_LATE";
        case NT_STATUS_NO_TRUST_LSA_SECRET: return "NT_STATUS_NO_TRUST_LSA_SECRET";
        case NT_STATUS_NO_TRUST_SAM_ACCOUNT: return "NT_STATUS_NO_TRUST_SAM_ACCOUNT";
        case NT_STATUS_TRUSTED_DOMAIN_FAILURE: return "NT_STATUS_TRUSTED_DOMAIN_FAILURE";
        case NT_STATUS_TRUSTED_RELATIONSHIP_FAILURE: return "NT_STATUS_TRUSTED_RELATIONSHIP_FAILURE";
        case NT_STATUS_EVENTLOG_FILE_CORRUPT: return "NT_STATUS_EVENTLOG_FILE_CORRUPT";
        case NT_STATUS_EVENTLOG_CANT_START: return "NT_STATUS_EVENTLOG_CANT_START";
        case NT_STATUS_TRUST_FAILURE: return "NT_STATUS_TRUST_FAILURE";
        case NT_STATUS_MUTANT_LIMIT_EXCEEDED: return "NT_STATUS_MUTANT_LIMIT_EXCEEDED";
        case NT_STATUS_NETLOGON_NOT_STARTED: return "NT_STATUS_NETLOGON_NOT_STARTED";
        case NT_STATUS_POSSIBLE_DEADLOCK: return "NT_STATUS_POSSIBLE_DEADLOCK";
        case NT_STATUS_NETWORK_CREDENTIAL_CONFLICT: return "NT_STATUS_NETWORK_CREDENTIAL_CONFLICT";
        case NT_STATUS_REMOTE_SESSION_LIMIT: return "NT_STATUS_REMOTE_SESSION_LIMIT";
        case NT_STATUS_EVENTLOG_FILE_CHANGED: return "NT_STATUS_EVENTLOG_FILE_CHANGED";
        case NT_STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT: return "NT_STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT";
        case NT_STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT: return "NT_STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT";
        case NT_STATUS_NOLOGON_SERVER_TRUST_ACCOUNT: return "NT_STATUS_NOLOGON_SERVER_TRUST_ACCOUNT";
        case NT_STATUS_DOMAIN_TRUST_INCONSISTENT: return "NT_STATUS_DOMAIN_TRUST_INCONSISTENT";
        case NT_STATUS_FS_DRIVER_REQUIRED: return "NT_STATUS_FS_DRIVER_REQUIRED";
        case NT_STATUS_NO_USER_SESSION_KEY: return "NT_STATUS_NO_USER_SESSION_KEY";
        case NT_STATUS_USER_SESSION_DELETED: return "NT_STATUS_USER_SESSION_DELETED";
        case NT_STATUS_RESOURCE_LANG_NOT_FOUND: return "NT_STATUS_RESOURCE_LANG_NOT_FOUND";
        case NT_STATUS_INVALID_BUFFER_SIZE: return "NT_STATUS_INVALID_BUFFER_SIZE";
        case NT_STATUS_INVALID_ADDRESS_COMPONENT: return "NT_STATUS_INVALID_ADDRESS_COMPONENT";
        case NT_STATUS_INVALID_ADDRESS_WILDCARD: return "NT_STATUS_INVALID_ADDRESS_WILDCARD";
        case NT_STATUS_TOO_MANY_ADDRESSES: return "NT_STATUS_TOO_MANY_ADDRESSES";
        case NT_STATUS_ADDRESS_ALREADY_EXISTS: return "NT_STATUS_ADDRESS_ALREADY_EXISTS";
        case NT_STATUS_ADDRESS_CLOSED: return "NT_STATUS_ADDRESS_CLOSED";
        case NT_STATUS_CONNECTION_DISCONNECTED: return "NT_STATUS_CONNECTION_DISCONNECTED";
        case NT_STATUS_CONNECTION_RESET: return "NT_STATUS_CONNECTION_RESET";
        case NT_STATUS_TOO_MANY_NODES: return "NT_STATUS_TOO_MANY_NODES";
        case NT_STATUS_TRANSACTION_ABORTED: return "NT_STATUS_TRANSACTION_ABORTED";
        case NT_STATUS_TRANSACTION_TIMED_OUT: return "NT_STATUS_TRANSACTION_TIMED_OUT";
        case NT_STATUS_TRANSACTION_NO_RELEASE: return "NT_STATUS_TRANSACTION_NO_RELEASE";
        case NT_STATUS_TRANSACTION_NO_MATCH: return "NT_STATUS_TRANSACTION_NO_MATCH";
        case NT_STATUS_TRANSACTION_RESPONDED: return "NT_STATUS_TRANSACTION_RESPONDED";
        case NT_STATUS_TRANSACTION_INVALID_ID: return "NT_STATUS_TRANSACTION_INVALID_ID";
        case NT_STATUS_TRANSACTION_INVALID_TYPE: return "NT_STATUS_TRANSACTION_INVALID_TYPE";
        case NT_STATUS_NOT_SERVER_SESSION: return "NT_STATUS_NOT_SERVER_SESSION";
        case NT_STATUS_NOT_CLIENT_SESSION: return "NT_STATUS_NOT_CLIENT_SESSION";
        case NT_STATUS_CANNOT_LOAD_REGISTRY_FILE: return "NT_STATUS_CANNOT_LOAD_REGISTRY_FILE";
        case NT_STATUS_DEBUG_ATTACH_FAILED: return "NT_STATUS_DEBUG_ATTACH_FAILED";
        case NT_STATUS_SYSTEM_PROCESS_TERMINATED: return "NT_STATUS_SYSTEM_PROCESS_TERMINATED";
        case NT_STATUS_DATA_NOT_ACCEPTED: return "NT_STATUS_DATA_NOT_ACCEPTED";
        case NT_STATUS_NO_BROWSER_SERVERS_FOUND: return "NT_STATUS_NO_BROWSER_SERVERS_FOUND";
        case NT_STATUS_VDM_HARD_ERROR: return "NT_STATUS_VDM_HARD_ERROR";
        case NT_STATUS_DRIVER_CANCEL_TIMEOUT: return "NT_STATUS_DRIVER_CANCEL_TIMEOUT";
        case NT_STATUS_REPLY_MESSAGE_MISMATCH: return "NT_STATUS_REPLY_MESSAGE_MISMATCH";
        case NT_STATUS_MAPPED_ALIGNMENT: return "NT_STATUS_MAPPED_ALIGNMENT";
        case NT_STATUS_IMAGE_CHECKSUM_MISMATCH: return "NT_STATUS_IMAGE_CHECKSUM_MISMATCH";
        case NT_STATUS_LOST_WRITEBEHIND_DATA: return "NT_STATUS_LOST_WRITEBEHIND_DATA";
        case NT_STATUS_CLIENT_SERVER_PARAMETERS_INVALID: return "NT_STATUS_CLIENT_SERVER_PARAMETERS_INVALID";
        case NT_STATUS_NOT_FOUND: return "NT_STATUS_NOT_FOUND";
        case NT_STATUS_NOT_TINY_STREAM: return "NT_STATUS_NOT_TINY_STREAM";
        case NT_STATUS_RECOVERY_FAILURE: return "NT_STATUS_RECOVERY_FAILURE";
        case NT_STATUS_STACK_OVERFLOW_READ: return "NT_STATUS_STACK_OVERFLOW_READ";
        case NT_STATUS_FAIL_CHECK: return "NT_STATUS_FAIL_CHECK";
        case NT_STATUS_DUPLICATE_OBJECTID: return "NT_STATUS_DUPLICATE_OBJECTID";
        case NT_STATUS_OBJECTID_EXISTS: return "NT_STATUS_OBJECTID_EXISTS";
        case NT_STATUS_CONVERT_TO_LARGE: return "NT_STATUS_CONVERT_TO_LARGE";
        case NT_STATUS_RETRY: return "NT_STATUS_RETRY";
        case NT_STATUS_FOUND_OUT_OF_SCOPE: return "NT_STATUS_FOUND_OUT_OF_SCOPE";
        case NT_STATUS_ALLOCATE_BUCKET: return "NT_STATUS_ALLOCATE_BUCKET";
        case NT_STATUS_PROPSET_NOT_FOUND: return "NT_STATUS_PROPSET_NOT_FOUND";
        case NT_STATUS_MARSHALL_OVERFLOW: return "NT_STATUS_MARSHALL_OVERFLOW";
        case NT_STATUS_INVALID_VARIANT: return "NT_STATUS_INVALID_VARIANT";
        case NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND: return "NT_STATUS_DOMAIN_CONTROLLER_NOT_FOUND";
        case NT_STATUS_ACCOUNT_LOCKED_OUT: return "NT_STATUS_ACCOUNT_LOCKED_OUT";
        case NT_STATUS_CONNECTION_REFUSED: return "NT_STATUS_CONNECTION_REFUSED";
        case NT_STATUS_GRACEFUL_DISCONNECT: return "NT_STATUS_GRACEFUL_DISCONNECT";
        case NT_STATUS_ADDRESS_ALREADY_ASSOCIATED: return "NT_STATUS_ADDRESS_ALREADY_ASSOCIATED";
        case NT_STATUS_ADDRESS_NOT_ASSOCIATED: return "NT_STATUS_ADDRESS_NOT_ASSOCIATED";
        case NT_STATUS_CONNECTION_INVALID: return "NT_STATUS_CONNECTION_INVALID";
        case NT_STATUS_CONNECTION_ACTIVE: return "NT_STATUS_CONNECTION_ACTIVE";
        case NT_STATUS_NETWORK_UNREACHABLE: return "NT_STATUS_NETWORK_UNREACHABLE";
        case NT_STATUS_HOST_UNREACHABLE: return "NT_STATUS_HOST_UNREACHABLE";
        case NT_STATUS_PROTOCOL_UNREACHABLE: return "NT_STATUS_PROTOCOL_UNREACHABLE";
        case NT_STATUS_PORT_UNREACHABLE: return "NT_STATUS_PORT_UNREACHABLE";
        case NT_STATUS_REQUEST_ABORTED: return "NT_STATUS_REQUEST_ABORTED";
        case NT_STATUS_CONNECTION_ABORTED: return "NT_STATUS_CONNECTION_ABORTED";
        case NT_STATUS_BAD_COMPRESSION_BUFFER: return "NT_STATUS_BAD_COMPRESSION_BUFFER";
        case NT_STATUS_USER_MAPPED_FILE: return "NT_STATUS_USER_MAPPED_FILE";
        case NT_STATUS_AUDIT_FAILED: return "NT_STATUS_AUDIT_FAILED";
        case NT_STATUS_TIMER_RESOLUTION_NOT_SET: return "NT_STATUS_TIMER_RESOLUTION_NOT_SET";
        case NT_STATUS_CONNECTION_COUNT_LIMIT: return "NT_STATUS_CONNECTION_COUNT_LIMIT";
        case NT_STATUS_LOGIN_TIME_RESTRICTION: return "NT_STATUS_LOGIN_TIME_RESTRICTION";
        case NT_STATUS_LOGIN_WKSTA_RESTRICTION: return "NT_STATUS_LOGIN_WKSTA_RESTRICTION";
        case NT_STATUS_IMAGE_MP_UP_MISMATCH: return "NT_STATUS_IMAGE_MP_UP_MISMATCH";
        case NT_STATUS_INSUFFICIENT_LOGON_INFO: return "NT_STATUS_INSUFFICIENT_LOGON_INFO";
        case NT_STATUS_BAD_DLL_ENTRYPOINT: return "NT_STATUS_BAD_DLL_ENTRYPOINT";
        case NT_STATUS_BAD_SERVICE_ENTRYPOINT: return "NT_STATUS_BAD_SERVICE_ENTRYPOINT";
        case NT_STATUS_LPC_REPLY_LOST: return "NT_STATUS_LPC_REPLY_LOST";
        case NT_STATUS_IP_ADDRESS_CONFLICT1: return "NT_STATUS_IP_ADDRESS_CONFLICT1";
        case NT_STATUS_IP_ADDRESS_CONFLICT2: return "NT_STATUS_IP_ADDRESS_CONFLICT2";
        case NT_STATUS_REGISTRY_QUOTA_LIMIT: return "NT_STATUS_REGISTRY_QUOTA_LIMIT";
        case NT_STATUS_NO_CALLBACK_ACTIVE: return "NT_STATUS_NO_CALLBACK_ACTIVE";
        case NT_STATUS_LICENSE_QUOTA_EXCEEDED: return "NT_STATUS_LICENSE_QUOTA_EXCEEDED";
        case NT_STATUS_PWD_TOO_SHORT: return "NT_STATUS_PWD_TOO_SHORT";
        case NT_STATUS_PWD_TOO_RECENT: return "NT_STATUS_PWD_TOO_RECENT";
        case NT_STATUS_PWD_HISTORY_CONFLICT: return "NT_STATUS_PWD_HISTORY_CONFLICT";
        case NT_STATUS_PLUGPLAY_NO_DEVICE: return "NT_STATUS_PLUGPLAY_NO_DEVICE";
        case NT_STATUS_UNSUPPORTED_COMPRESSION: return "NT_STATUS_UNSUPPORTED_COMPRESSION";
        case NT_STATUS_INVALID_HW_PROFILE: return "NT_STATUS_INVALID_HW_PROFILE";
        case NT_STATUS_INVALID_PLUGPLAY_DEVICE_PATH: return "NT_STATUS_INVALID_PLUGPLAY_DEVICE_PATH";
        case NT_STATUS_DRIVER_ORDINAL_NOT_FOUND: return "NT_STATUS_DRIVER_ORDINAL_NOT_FOUND";
        case NT_STATUS_DRIVER_ENTRYPOINT_NOT_FOUND: return "NT_STATUS_DRIVER_ENTRYPOINT_NOT_FOUND";
        case NT_STATUS_RESOURCE_NOT_OWNED: return "NT_STATUS_RESOURCE_NOT_OWNED";
        case NT_STATUS_TOO_MANY_LINKS: return "NT_STATUS_TOO_MANY_LINKS";
        case NT_STATUS_QUOTA_LIST_INCONSISTENT: return "NT_STATUS_QUOTA_LIST_INCONSISTENT";
        case NT_STATUS_FILE_IS_OFFLINE: return "NT_STATUS_FILE_IS_OFFLINE";
        case NT_STATUS_EVALUATION_EXPIRATION: return "NT_STATUS_EVALUATION_EXPIRATION";
        case NT_STATUS_ILLEGAL_DLL_RELOCATION: return "NT_STATUS_ILLEGAL_DLL_RELOCATION";
        case NT_STATUS_LICENSE_VIOLATION: return "NT_STATUS_LICENSE_VIOLATION";
        case NT_STATUS_DLL_INIT_FAILED_LOGOFF: return "NT_STATUS_DLL_INIT_FAILED_LOGOFF";
        case NT_STATUS_DRIVER_UNABLE_TO_LOAD: return "NT_STATUS_DRIVER_UNABLE_TO_LOAD";
        case NT_STATUS_DFS_UNAVAILABLE: return "NT_STATUS_DFS_UNAVAILABLE";
        case NT_STATUS_VOLUME_DISMOUNTED: return "NT_STATUS_VOLUME_DISMOUNTED";
        case NT_STATUS_WX86_INTERNAL_ERROR: return "NT_STATUS_WX86_INTERNAL_ERROR";
        case NT_STATUS_WX86_FLOAT_STACK_CHECK: return "NT_STATUS_WX86_FLOAT_STACK_CHECK";
        case NT_STATUS_VALIDATE_CONTINUE: return "NT_STATUS_VALIDATE_CONTINUE";
        case NT_STATUS_NO_MATCH: return "NT_STATUS_NO_MATCH";
        case NT_STATUS_NO_MORE_MATCHES: return "NT_STATUS_NO_MORE_MATCHES";
        case NT_STATUS_NOT_A_REPARSE_POINT: return "NT_STATUS_NOT_A_REPARSE_POINT";
        case NT_STATUS_IO_REPARSE_TAG_INVALID: return "NT_STATUS_IO_REPARSE_TAG_INVALID";
        case NT_STATUS_IO_REPARSE_TAG_MISMATCH: return "NT_STATUS_IO_REPARSE_TAG_MISMATCH";
        case NT_STATUS_IO_REPARSE_DATA_INVALID: return "NT_STATUS_IO_REPARSE_DATA_INVALID";
        case NT_STATUS_IO_REPARSE_TAG_NOT_HANDLED: return "NT_STATUS_IO_REPARSE_TAG_NOT_HANDLED";
        case NT_STATUS_REPARSE_POINT_NOT_RESOLVED: return "NT_STATUS_REPARSE_POINT_NOT_RESOLVED";
        case NT_STATUS_DIRECTORY_IS_A_REPARSE_POINT: return "NT_STATUS_DIRECTORY_IS_A_REPARSE_POINT";
        case NT_STATUS_RANGE_LIST_CONFLICT: return "NT_STATUS_RANGE_LIST_CONFLICT";
        case NT_STATUS_SOURCE_ELEMENT_EMPTY: return "NT_STATUS_SOURCE_ELEMENT_EMPTY";
        case NT_STATUS_DESTINATION_ELEMENT_FULL: return "NT_STATUS_DESTINATION_ELEMENT_FULL";
        case NT_STATUS_ILLEGAL_ELEMENT_ADDRESS: return "NT_STATUS_ILLEGAL_ELEMENT_ADDRESS";
        case NT_STATUS_MAGAZINE_NOT_PRESENT: return "NT_STATUS_MAGAZINE_NOT_PRESENT";
        case NT_STATUS_REINITIALIZATION_NEEDED: return "NT_STATUS_REINITIALIZATION_NEEDED";
        case NT_STATUS_DEVICE_REQUIRES_CLEANING: return "NT_STATUS_DEVICE_REQUIRES_CLEANING";
        case NT_STATUS_DEVICE_DOOR_OPEN: return "NT_STATUS_DEVICE_DOOR_OPEN";
        case NT_STATUS_ENCRYPTION_FAILED: return "NT_STATUS_ENCRYPTION_FAILED";
        case NT_STATUS_DECRYPTION_FAILED: return "NT_STATUS_DECRYPTION_FAILED";
        case NT_STATUS_RANGE_NOT_FOUND: return "NT_STATUS_RANGE_NOT_FOUND";
        case NT_STATUS_NO_RECOVERY_POLICY: return "NT_STATUS_NO_RECOVERY_POLICY";
        case NT_STATUS_NO_EFS: return "NT_STATUS_NO_EFS";
        case NT_STATUS_WRONG_EFS: return "NT_STATUS_WRONG_EFS";
        case NT_STATUS_NO_USER_KEYS: return "NT_STATUS_NO_USER_KEYS";
        case NT_STATUS_FILE_NOT_ENCRYPTED: return "NT_STATUS_FILE_NOT_ENCRYPTED";
        case NT_STATUS_NOT_EXPORT_FORMAT: return "NT_STATUS_NOT_EXPORT_FORMAT";
        case NT_STATUS_FILE_ENCRYPTED: return "NT_STATUS_FILE_ENCRYPTED";
        case NT_STATUS_WAKE_SYSTEM: return "NT_STATUS_WAKE_SYSTEM";
        case NT_STATUS_WMI_GUID_NOT_FOUND: return "NT_STATUS_WMI_GUID_NOT_FOUND";
        case NT_STATUS_WMI_INSTANCE_NOT_FOUND: return "NT_STATUS_WMI_INSTANCE_NOT_FOUND";
        case NT_STATUS_WMI_ITEMID_NOT_FOUND: return "NT_STATUS_WMI_ITEMID_NOT_FOUND";
        case NT_STATUS_WMI_TRY_AGAIN: return "NT_STATUS_WMI_TRY_AGAIN";
        case NT_STATUS_SHARED_POLICY: return "NT_STATUS_SHARED_POLICY";
        case NT_STATUS_POLICY_OBJECT_NOT_FOUND: return "NT_STATUS_POLICY_OBJECT_NOT_FOUND";
        case NT_STATUS_POLICY_ONLY_IN_DS: return "NT_STATUS_POLICY_ONLY_IN_DS";
        case NT_STATUS_VOLUME_NOT_UPGRADED: return "NT_STATUS_VOLUME_NOT_UPGRADED";
        case NT_STATUS_REMOTE_STORAGE_NOT_ACTIVE: return "NT_STATUS_REMOTE_STORAGE_NOT_ACTIVE";
        case NT_STATUS_REMOTE_STORAGE_MEDIA_ERROR: return "NT_STATUS_REMOTE_STORAGE_MEDIA_ERROR";
        case NT_STATUS_NO_TRACKING_SERVICE: return "NT_STATUS_NO_TRACKING_SERVICE";
        case NT_STATUS_SERVER_SID_MISMATCH: return "NT_STATUS_SERVER_SID_MISMATCH";
        case NT_STATUS_DS_NO_ATTRIBUTE_OR_VALUE: return "NT_STATUS_DS_NO_ATTRIBUTE_OR_VALUE";
        case NT_STATUS_DS_INVALID_ATTRIBUTE_SYNTAX: return "NT_STATUS_DS_INVALID_ATTRIBUTE_SYNTAX";
        case NT_STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED: return "NT_STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED";
        case NT_STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS: return "NT_STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS";
        case NT_STATUS_DS_BUSY: return "NT_STATUS_DS_BUSY";
        case NT_STATUS_DS_UNAVAILABLE: return "NT_STATUS_DS_UNAVAILABLE";
        case NT_STATUS_DS_NO_RIDS_ALLOCATED: return "NT_STATUS_DS_NO_RIDS_ALLOCATED";
        case NT_STATUS_DS_NO_MORE_RIDS: return "NT_STATUS_DS_NO_MORE_RIDS";
        case NT_STATUS_DS_INCORRECT_ROLE_OWNER: return "NT_STATUS_DS_INCORRECT_ROLE_OWNER";
        case NT_STATUS_DS_RIDMGR_INIT_ERROR: return "NT_STATUS_DS_RIDMGR_INIT_ERROR";
        case NT_STATUS_DS_OBJ_CLASS_VIOLATION: return "NT_STATUS_DS_OBJ_CLASS_VIOLATION";
        case NT_STATUS_DS_CANT_ON_NON_LEAF: return "NT_STATUS_DS_CANT_ON_NON_LEAF";
        case NT_STATUS_DS_CANT_ON_RDN: return "NT_STATUS_DS_CANT_ON_RDN";
        case NT_STATUS_DS_CANT_MOD_OBJ_CLASS: return "NT_STATUS_DS_CANT_MOD_OBJ_CLASS";
        case NT_STATUS_DS_CROSS_DOM_MOVE_FAILED: return "NT_STATUS_DS_CROSS_DOM_MOVE_FAILED";
        case NT_STATUS_DS_GC_NOT_AVAILABLE: return "NT_STATUS_DS_GC_NOT_AVAILABLE";
        case NT_STATUS_DIRECTORY_SERVICE_REQUIRED: return "NT_STATUS_DIRECTORY_SERVICE_REQUIRED";
        case NT_STATUS_REPARSE_ATTRIBUTE_CONFLICT: return "NT_STATUS_REPARSE_ATTRIBUTE_CONFLICT";
        case NT_STATUS_CANT_ENABLE_DENY_ONLY: return "NT_STATUS_CANT_ENABLE_DENY_ONLY";
        case NT_STATUS_FLOAT_MULTIPLE_FAULTS: return "NT_STATUS_FLOAT_MULTIPLE_FAULTS";
        case NT_STATUS_FLOAT_MULTIPLE_TRAPS: return "NT_STATUS_FLOAT_MULTIPLE_TRAPS";
        case NT_STATUS_DEVICE_REMOVED: return "NT_STATUS_DEVICE_REMOVED";
        case NT_STATUS_JOURNAL_DELETE_IN_PROGRESS: return "NT_STATUS_JOURNAL_DELETE_IN_PROGRESS";
        case NT_STATUS_JOURNAL_NOT_ACTIVE: return "NT_STATUS_JOURNAL_NOT_ACTIVE";
        case NT_STATUS_NOINTERFACE: return "NT_STATUS_NOINTERFACE";
        case NT_STATUS_DS_ADMIN_LIMIT_EXCEEDED: return "NT_STATUS_DS_ADMIN_LIMIT_EXCEEDED";
        case NT_STATUS_DRIVER_FAILED_SLEEP: return "NT_STATUS_DRIVER_FAILED_SLEEP";
        case NT_STATUS_MUTUAL_AUTHENTICATION_FAILED: return "NT_STATUS_MUTUAL_AUTHENTICATION_FAILED";
        case NT_STATUS_CORRUPT_SYSTEM_FILE: return "NT_STATUS_CORRUPT_SYSTEM_FILE";
        case NT_STATUS_DATATYPE_MISALIGNMENT_ERROR: return "NT_STATUS_DATATYPE_MISALIGNMENT_ERROR";
        case NT_STATUS_WMI_READ_ONLY: return "NT_STATUS_WMI_READ_ONLY";
        case NT_STATUS_WMI_SET_FAILURE: return "NT_STATUS_WMI_SET_FAILURE";
        case NT_STATUS_COMMITMENT_MINIMUM: return "NT_STATUS_COMMITMENT_MINIMUM";
        case NT_STATUS_REG_NAT_CONSUMPTION: return "NT_STATUS_REG_NAT_CONSUMPTION";
        case NT_STATUS_TRANSPORT_FULL: return "NT_STATUS_TRANSPORT_FULL";
        case NT_STATUS_DS_SAM_INIT_FAILURE: return "NT_STATUS_DS_SAM_INIT_FAILURE";
        case NT_STATUS_ONLY_IF_CONNECTED: return "NT_STATUS_ONLY_IF_CONNECTED";
        case NT_STATUS_DS_SENSITIVE_GROUP_VIOLATION: return "NT_STATUS_DS_SENSITIVE_GROUP_VIOLATION";
        case NT_STATUS_PNP_RESTART_ENUMERATION: return "NT_STATUS_PNP_RESTART_ENUMERATION";
        case NT_STATUS_JOURNAL_ENTRY_DELETED: return "NT_STATUS_JOURNAL_ENTRY_DELETED";
        case NT_STATUS_DS_CANT_MOD_PRIMARYGROUPID: return "NT_STATUS_DS_CANT_MOD_PRIMARYGROUPID";
        case NT_STATUS_SYSTEM_IMAGE_BAD_SIGNATURE: return "NT_STATUS_SYSTEM_IMAGE_BAD_SIGNATURE";
        case NT_STATUS_PNP_REBOOT_REQUIRED: return "NT_STATUS_PNP_REBOOT_REQUIRED";
        case NT_STATUS_POWER_STATE_INVALID: return "NT_STATUS_POWER_STATE_INVALID";
        case NT_STATUS_DS_INVALID_GROUP_TYPE: return "NT_STATUS_DS_INVALID_GROUP_TYPE";
        case NT_STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN: return "NT_STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN";
        case NT_STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN: return "NT_STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN";
        case NT_STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER: return "NT_STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER";
        case NT_STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER: return "NT_STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER";
        case NT_STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER: return "NT_STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER";
        case NT_STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER: return "NT_STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER";
        case NT_STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER: return "NT_STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER";
        case NT_STATUS_DS_HAVE_PRIMARY_MEMBERS: return "NT_STATUS_DS_HAVE_PRIMARY_MEMBERS";
        case NT_STATUS_WMI_NOT_SUPPORTED: return "NT_STATUS_WMI_NOT_SUPPORTED";
        case NT_STATUS_INSUFFICIENT_POWER: return "NT_STATUS_INSUFFICIENT_POWER";
        case NT_STATUS_SAM_NEED_BOOTKEY_PASSWORD: return "NT_STATUS_SAM_NEED_BOOTKEY_PASSWORD";
        case NT_STATUS_SAM_NEED_BOOTKEY_FLOPPY: return "NT_STATUS_SAM_NEED_BOOTKEY_FLOPPY";
        case NT_STATUS_DS_CANT_START: return "NT_STATUS_DS_CANT_START";
        case NT_STATUS_DS_INIT_FAILURE: return "NT_STATUS_DS_INIT_FAILURE";
        case NT_STATUS_SAM_INIT_FAILURE: return "NT_STATUS_SAM_INIT_FAILURE";
        case NT_STATUS_DS_GC_REQUIRED: return "NT_STATUS_DS_GC_REQUIRED";
        case NT_STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY: return "NT_STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY";
        case NT_STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS: return "NT_STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS";
        case NT_STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED: return "NT_STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED";
        case NT_STATUS_MULTIPLE_FAULT_VIOLATION: return "NT_STATUS_MULTIPLE_FAULT_VIOLATION";
        case NT_STATUS_CURRENT_DOMAIN_NOT_ALLOWED: return "NT_STATUS_CURRENT_DOMAIN_NOT_ALLOWED";
        case NT_STATUS_CANNOT_MAKE: return "NT_STATUS_CANNOT_MAKE";
        case NT_STATUS_SYSTEM_SHUTDOWN: return "NT_STATUS_SYSTEM_SHUTDOWN";
        case NT_STATUS_DS_INIT_FAILURE_CONSOLE: return "NT_STATUS_DS_INIT_FAILURE_CONSOLE";
        case NT_STATUS_DS_SAM_INIT_FAILURE_CONSOLE: return "NT_STATUS_DS_SAM_INIT_FAILURE_CONSOLE";
        case NT_STATUS_UNFINISHED_CONTEXT_DELETED: return "NT_STATUS_UNFINISHED_CONTEXT_DELETED";
        case NT_STATUS_NO_TGT_REPLY: return "NT_STATUS_NO_TGT_REPLY";
        case NT_STATUS_OBJECTID_NOT_FOUND: return "NT_STATUS_OBJECTID_NOT_FOUND";
        case NT_STATUS_NO_IP_ADDRESSES: return "NT_STATUS_NO_IP_ADDRESSES";
        case NT_STATUS_WRONG_CREDENTIAL_HANDLE: return "NT_STATUS_WRONG_CREDENTIAL_HANDLE";
        case NT_STATUS_CRYPTO_SYSTEM_INVALID: return "NT_STATUS_CRYPTO_SYSTEM_INVALID";
        case NT_STATUS_MAX_REFERRALS_EXCEEDED: return "NT_STATUS_MAX_REFERRALS_EXCEEDED";
        case NT_STATUS_MUST_BE_KDC: return "NT_STATUS_MUST_BE_KDC";
        case NT_STATUS_STRONG_CRYPTO_NOT_SUPPORTED: return "NT_STATUS_STRONG_CRYPTO_NOT_SUPPORTED";
        case NT_STATUS_TOO_MANY_PRINCIPALS: return "NT_STATUS_TOO_MANY_PRINCIPALS";
        case NT_STATUS_NO_PA_DATA: return "NT_STATUS_NO_PA_DATA";
        case NT_STATUS_PKINIT_NAME_MISMATCH: return "NT_STATUS_PKINIT_NAME_MISMATCH";
        case NT_STATUS_SMARTCARD_LOGON_REQUIRED: return "NT_STATUS_SMARTCARD_LOGON_REQUIRED";
        case NT_STATUS_KDC_INVALID_REQUEST: return "NT_STATUS_KDC_INVALID_REQUEST";
        case NT_STATUS_KDC_UNABLE_TO_REFER: return "NT_STATUS_KDC_UNABLE_TO_REFER";
        case NT_STATUS_KDC_UNKNOWN_ETYPE: return "NT_STATUS_KDC_UNKNOWN_ETYPE";
        case NT_STATUS_SHUTDOWN_IN_PROGRESS: return "NT_STATUS_SHUTDOWN_IN_PROGRESS";
        case NT_STATUS_SERVER_SHUTDOWN_IN_PROGRESS: return "NT_STATUS_SERVER_SHUTDOWN_IN_PROGRESS";
        case NT_STATUS_NOT_SUPPORTED_ON_SBS: return "NT_STATUS_NOT_SUPPORTED_ON_SBS";
        case NT_STATUS_WMI_GUID_DISCONNECTED: return "NT_STATUS_WMI_GUID_DISCONNECTED";
        case NT_STATUS_WMI_ALREADY_DISABLED: return "NT_STATUS_WMI_ALREADY_DISABLED";
        case NT_STATUS_WMI_ALREADY_ENABLED: return "NT_STATUS_WMI_ALREADY_ENABLED";
        case NT_STATUS_MFT_TOO_FRAGMENTED: return "NT_STATUS_MFT_TOO_FRAGMENTED";
        case NT_STATUS_COPY_PROTECTION_FAILURE: return "NT_STATUS_COPY_PROTECTION_FAILURE";
        case NT_STATUS_CSS_AUTHENTICATION_FAILURE: return "NT_STATUS_CSS_AUTHENTICATION_FAILURE";
        case NT_STATUS_CSS_KEY_NOT_PRESENT: return "NT_STATUS_CSS_KEY_NOT_PRESENT";
        case NT_STATUS_CSS_KEY_NOT_ESTABLISHED: return "NT_STATUS_CSS_KEY_NOT_ESTABLISHED";
        case NT_STATUS_CSS_SCRAMBLED_SECTOR: return "NT_STATUS_CSS_SCRAMBLED_SECTOR";
        case NT_STATUS_CSS_REGION_MISMATCH: return "NT_STATUS_CSS_REGION_MISMATCH";
        case NT_STATUS_CSS_RESETS_EXHAUSTED: return "NT_STATUS_CSS_RESETS_EXHAUSTED";
        case NT_STATUS_PKINIT_FAILURE: return "NT_STATUS_PKINIT_FAILURE";
        case NT_STATUS_SMARTCARD_SUBSYSTEM_FAILURE: return "NT_STATUS_SMARTCARD_SUBSYSTEM_FAILURE";
        case NT_STATUS_NO_KERB_KEY: return "NT_STATUS_NO_KERB_KEY";
        case NT_STATUS_HOST_DOWN: return "NT_STATUS_HOST_DOWN";
        case NT_STATUS_UNSUPPORTED_PREAUTH: return "NT_STATUS_UNSUPPORTED_PREAUTH";
        case NT_STATUS_EFS_ALG_BLOB_TOO_BIG: return "NT_STATUS_EFS_ALG_BLOB_TOO_BIG";
        case NT_STATUS_PORT_NOT_SET: return "NT_STATUS_PORT_NOT_SET";
        case NT_STATUS_DEBUGGER_INACTIVE: return "NT_STATUS_DEBUGGER_INACTIVE";
        case NT_STATUS_DS_VERSION_CHECK_FAILURE: return "NT_STATUS_DS_VERSION_CHECK_FAILURE";
        case NT_STATUS_AUDITING_DISABLED: return "NT_STATUS_AUDITING_DISABLED";
        case NT_STATUS_PRENT4_MACHINE_ACCOUNT: return "NT_STATUS_PRENT4_MACHINE_ACCOUNT";
        case NT_STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER: return "NT_STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER";
        case NT_STATUS_INVALID_IMAGE_WIN_32: return "NT_STATUS_INVALID_IMAGE_WIN_32";
        case NT_STATUS_INVALID_IMAGE_WIN_64: return "NT_STATUS_INVALID_IMAGE_WIN_64";
        case NT_STATUS_BAD_BINDINGS: return "NT_STATUS_BAD_BINDINGS";
        case NT_STATUS_NETWORK_SESSION_EXPIRED: return "NT_STATUS_NETWORK_SESSION_EXPIRED";
        case NT_STATUS_APPHELP_BLOCK: return "NT_STATUS_APPHELP_BLOCK";
        case NT_STATUS_ALL_SIDS_FILTERED: return "NT_STATUS_ALL_SIDS_FILTERED";
        case NT_STATUS_NOT_SAFE_MODE_DRIVER: return "NT_STATUS_NOT_SAFE_MODE_DRIVER";
        case NT_STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT: return "NT_STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT";
        case NT_STATUS_ACCESS_DISABLED_BY_POLICY_PATH: return "NT_STATUS_ACCESS_DISABLED_BY_POLICY_PATH";
        case NT_STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER: return "NT_STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER";
        case NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER: return "NT_STATUS_ACCESS_DISABLED_BY_POLICY_OTHER";
        case NT_STATUS_FAILED_DRIVER_ENTRY: return "NT_STATUS_FAILED_DRIVER_ENTRY";
        case NT_STATUS_DEVICE_ENUMERATION_ERROR: return "NT_STATUS_DEVICE_ENUMERATION_ERROR";
        case NT_STATUS_WAIT_FOR_OPLOCK: return "NT_STATUS_WAIT_FOR_OPLOCK";
        case NT_STATUS_MOUNT_POINT_NOT_RESOLVED: return "NT_STATUS_MOUNT_POINT_NOT_RESOLVED";
        case NT_STATUS_INVALID_DEVICE_OBJECT_PARAMETER: return "NT_STATUS_INVALID_DEVICE_OBJECT_PARAMETER";
        case NT_STATUS_MCA_OCCURED: return "NT_STATUS_MCA_OCCURED";
        case NT_STATUS_DRIVER_BLOCKED_CRITICAL: return "NT_STATUS_DRIVER_BLOCKED_CRITICAL";
        case NT_STATUS_DRIVER_BLOCKED: return "NT_STATUS_DRIVER_BLOCKED";
        case NT_STATUS_DRIVER_DATABASE_ERROR: return "NT_STATUS_DRIVER_DATABASE_ERROR";
        case NT_STATUS_SYSTEM_HIVE_TOO_LARGE: return "NT_STATUS_SYSTEM_HIVE_TOO_LARGE";
        case NT_STATUS_INVALID_IMPORT_OF_NON_DLL: return "NT_STATUS_INVALID_IMPORT_OF_NON_DLL";
        case NT_STATUS_DS_SHUTTING_DOWN: return "NT_STATUS_DS_SHUTTING_DOWN";
        case NT_STATUS_SMARTCARD_WRONG_PIN: return "NT_STATUS_SMARTCARD_WRONG_PIN";
        case NT_STATUS_SMARTCARD_CARD_BLOCKED: return "NT_STATUS_SMARTCARD_CARD_BLOCKED";
        case NT_STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED: return "NT_STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED";
        case NT_STATUS_SMARTCARD_NO_CARD: return "NT_STATUS_SMARTCARD_NO_CARD";
        case NT_STATUS_SMARTCARD_NO_KEY_CONTAINER: return "NT_STATUS_SMARTCARD_NO_KEY_CONTAINER";
        case NT_STATUS_SMARTCARD_NO_CERTIFICATE: return "NT_STATUS_SMARTCARD_NO_CERTIFICATE";
        case NT_STATUS_SMARTCARD_NO_KEYSET: return "NT_STATUS_SMARTCARD_NO_KEYSET";
        case NT_STATUS_SMARTCARD_IO_ERROR: return "NT_STATUS_SMARTCARD_IO_ERROR";
        case NT_STATUS_DOWNGRADE_DETECTED: return "NT_STATUS_DOWNGRADE_DETECTED";
        case NT_STATUS_SMARTCARD_CERT_REVOKED: return "NT_STATUS_SMARTCARD_CERT_REVOKED";
        case NT_STATUS_ISSUING_CA_UNTRUSTED: return "NT_STATUS_ISSUING_CA_UNTRUSTED";
        case NT_STATUS_REVOCATION_OFFLINE_C: return "NT_STATUS_REVOCATION_OFFLINE_C";
        case NT_STATUS_PKINIT_CLIENT_FAILURE: return "NT_STATUS_PKINIT_CLIENT_FAILURE";
        case NT_STATUS_SMARTCARD_CERT_EXPIRED: return "NT_STATUS_SMARTCARD_CERT_EXPIRED";
        case NT_STATUS_DRIVER_FAILED_PRIOR_UNLOAD: return "NT_STATUS_DRIVER_FAILED_PRIOR_UNLOAD";
        case NT_STATUS_WOW_ASSERTION: return "NT_STATUS_WOW_ASSERTION";
        case RPC_NT_INVALID_STRING_BINDING: return "RPC_NT_INVALID_STRING_BINDING";
        case RPC_NT_WRONG_KIND_OF_BINDING: return "RPC_NT_WRONG_KIND_OF_BINDING";
        case RPC_NT_INVALID_BINDING: return "RPC_NT_INVALID_BINDING";
        case RPC_NT_PROTSEQ_NOT_SUPPORTED: return "RPC_NT_PROTSEQ_NOT_SUPPORTED";
        case RPC_NT_INVALID_RPC_PROTSEQ: return "RPC_NT_INVALID_RPC_PROTSEQ";
        case RPC_NT_INVALID_STRING_UUID: return "RPC_NT_INVALID_STRING_UUID";
        case RPC_NT_INVALID_ENDPOINT_FORMAT: return "RPC_NT_INVALID_ENDPOINT_FORMAT";
        case RPC_NT_INVALID_NET_ADDR: return "RPC_NT_INVALID_NET_ADDR";
        case RPC_NT_NO_ENDPOINT_FOUND: return "RPC_NT_NO_ENDPOINT_FOUND";
        case RPC_NT_INVALID_TIMEOUT: return "RPC_NT_INVALID_TIMEOUT";
        case RPC_NT_OBJECT_NOT_FOUND: return "RPC_NT_OBJECT_NOT_FOUND";
        case RPC_NT_ALREADY_REGISTERED: return "RPC_NT_ALREADY_REGISTERED";
        case RPC_NT_TYPE_ALREADY_REGISTERED: return "RPC_NT_TYPE_ALREADY_REGISTERED";
        case RPC_NT_ALREADY_LISTENING: return "RPC_NT_ALREADY_LISTENING";
        case RPC_NT_NO_PROTSEQS_REGISTERED: return "RPC_NT_NO_PROTSEQS_REGISTERED";
        case RPC_NT_NOT_LISTENING: return "RPC_NT_NOT_LISTENING";
        case RPC_NT_UNKNOWN_MGR_TYPE: return "RPC_NT_UNKNOWN_MGR_TYPE";
        case RPC_NT_UNKNOWN_IF: return "RPC_NT_UNKNOWN_IF";
        case RPC_NT_NO_BINDINGS: return "RPC_NT_NO_BINDINGS";
        case RPC_NT_NO_PROTSEQS: return "RPC_NT_NO_PROTSEQS";
        case RPC_NT_CANT_CREATE_ENDPOINT: return "RPC_NT_CANT_CREATE_ENDPOINT";
        case RPC_NT_OUT_OF_RESOURCES: return "RPC_NT_OUT_OF_RESOURCES";
        case RPC_NT_SERVER_UNAVAILABLE: return "RPC_NT_SERVER_UNAVAILABLE";
        case RPC_NT_SERVER_TOO_BUSY: return "RPC_NT_SERVER_TOO_BUSY";
        case RPC_NT_INVALID_NETWORK_OPTIONS: return "RPC_NT_INVALID_NETWORK_OPTIONS";
        case RPC_NT_NO_CALL_ACTIVE: return "RPC_NT_NO_CALL_ACTIVE";
        case RPC_NT_CALL_FAILED: return "RPC_NT_CALL_FAILED";
        case RPC_NT_CALL_FAILED_DNE: return "RPC_NT_CALL_FAILED_DNE";
        case RPC_NT_PROTOCOL_ERROR: return "RPC_NT_PROTOCOL_ERROR";
        case RPC_NT_UNSUPPORTED_TRANS_SYN: return "RPC_NT_UNSUPPORTED_TRANS_SYN";
        case RPC_NT_UNSUPPORTED_TYPE: return "RPC_NT_UNSUPPORTED_TYPE";
        case RPC_NT_INVALID_TAG: return "RPC_NT_INVALID_TAG";
        case RPC_NT_INVALID_BOUND: return "RPC_NT_INVALID_BOUND";
        case RPC_NT_NO_ENTRY_NAME: return "RPC_NT_NO_ENTRY_NAME";
        case RPC_NT_INVALID_NAME_SYNTAX: return "RPC_NT_INVALID_NAME_SYNTAX";
        case RPC_NT_UNSUPPORTED_NAME_SYNTAX: return "RPC_NT_UNSUPPORTED_NAME_SYNTAX";
        case RPC_NT_UUID_NO_ADDRESS: return "RPC_NT_UUID_NO_ADDRESS";
        case RPC_NT_DUPLICATE_ENDPOINT: return "RPC_NT_DUPLICATE_ENDPOINT";
        case RPC_NT_UNKNOWN_AUTHN_TYPE: return "RPC_NT_UNKNOWN_AUTHN_TYPE";
        case RPC_NT_MAX_CALLS_TOO_SMALL: return "RPC_NT_MAX_CALLS_TOO_SMALL";
        case RPC_NT_STRING_TOO_LONG: return "RPC_NT_STRING_TOO_LONG";
        case RPC_NT_PROTSEQ_NOT_FOUND: return "RPC_NT_PROTSEQ_NOT_FOUND";
        case RPC_NT_PROCNUM_OUT_OF_RANGE: return "RPC_NT_PROCNUM_OUT_OF_RANGE";
        case RPC_NT_BINDING_HAS_NO_AUTH: return "RPC_NT_BINDING_HAS_NO_AUTH";
        case RPC_NT_UNKNOWN_AUTHN_SERVICE: return "RPC_NT_UNKNOWN_AUTHN_SERVICE";
        case RPC_NT_UNKNOWN_AUTHN_LEVEL: return "RPC_NT_UNKNOWN_AUTHN_LEVEL";
        case RPC_NT_INVALID_AUTH_IDENTITY: return "RPC_NT_INVALID_AUTH_IDENTITY";
        case RPC_NT_UNKNOWN_AUTHZ_SERVICE: return "RPC_NT_UNKNOWN_AUTHZ_SERVICE";
        case EPT_NT_INVALID_ENTRY: return "EPT_NT_INVALID_ENTRY";
        case EPT_NT_CANT_PERFORM_OP: return "EPT_NT_CANT_PERFORM_OP";
        case EPT_NT_NOT_REGISTERED: return "EPT_NT_NOT_REGISTERED";
        case RPC_NT_NOTHING_TO_EXPORT: return "RPC_NT_NOTHING_TO_EXPORT";
        case RPC_NT_INCOMPLETE_NAME: return "RPC_NT_INCOMPLETE_NAME";
        case RPC_NT_INVALID_VERS_OPTION: return "RPC_NT_INVALID_VERS_OPTION";
        case RPC_NT_NO_MORE_MEMBERS: return "RPC_NT_NO_MORE_MEMBERS";
        case RPC_NT_NOT_ALL_OBJS_UNEXPORTED: return "RPC_NT_NOT_ALL_OBJS_UNEXPORTED";
        case RPC_NT_INTERFACE_NOT_FOUND: return "RPC_NT_INTERFACE_NOT_FOUND";
        case RPC_NT_ENTRY_ALREADY_EXISTS: return "RPC_NT_ENTRY_ALREADY_EXISTS";
        case RPC_NT_ENTRY_NOT_FOUND: return "RPC_NT_ENTRY_NOT_FOUND";
        case RPC_NT_NAME_SERVICE_UNAVAILABLE: return "RPC_NT_NAME_SERVICE_UNAVAILABLE";
        case RPC_NT_INVALID_NAF_ID: return "RPC_NT_INVALID_NAF_ID";
        case RPC_NT_CANNOT_SUPPORT: return "RPC_NT_CANNOT_SUPPORT";
        case RPC_NT_NO_CONTEXT_AVAILABLE: return "RPC_NT_NO_CONTEXT_AVAILABLE";
        case RPC_NT_INTERNAL_ERROR: return "RPC_NT_INTERNAL_ERROR";
        case RPC_NT_ZERO_DIVIDE: return "RPC_NT_ZERO_DIVIDE";
        case RPC_NT_ADDRESS_ERROR: return "RPC_NT_ADDRESS_ERROR";
        case RPC_NT_FP_DIV_ZERO: return "RPC_NT_FP_DIV_ZERO";
        case RPC_NT_FP_UNDERFLOW: return "RPC_NT_FP_UNDERFLOW";
        case RPC_NT_FP_OVERFLOW: return "RPC_NT_FP_OVERFLOW";
        case RPC_NT_CALL_IN_PROGRESS: return "RPC_NT_CALL_IN_PROGRESS";
        case RPC_NT_NO_MORE_BINDINGS: return "RPC_NT_NO_MORE_BINDINGS";
        case RPC_NT_GROUP_MEMBER_NOT_FOUND: return "RPC_NT_GROUP_MEMBER_NOT_FOUND";
        case EPT_NT_CANT_CREATE: return "EPT_NT_CANT_CREATE";
        case RPC_NT_INVALID_OBJECT: return "RPC_NT_INVALID_OBJECT";
        case RPC_NT_NO_INTERFACES: return "RPC_NT_NO_INTERFACES";
        case RPC_NT_CALL_CANCELLED: return "RPC_NT_CALL_CANCELLED";
        case RPC_NT_BINDING_INCOMPLETE: return "RPC_NT_BINDING_INCOMPLETE";
        case RPC_NT_COMM_FAILURE: return "RPC_NT_COMM_FAILURE";
        case RPC_NT_UNSUPPORTED_AUTHN_LEVEL: return "RPC_NT_UNSUPPORTED_AUTHN_LEVEL";
        case RPC_NT_NO_PRINC_NAME: return "RPC_NT_NO_PRINC_NAME";
        case RPC_NT_NOT_RPC_ERROR: return "RPC_NT_NOT_RPC_ERROR";
        case RPC_NT_UUID_LOCAL_ONLY: return "RPC_NT_UUID_LOCAL_ONLY";
        case RPC_NT_SEC_PKG_ERROR: return "RPC_NT_SEC_PKG_ERROR";
        case RPC_NT_NOT_CANCELLED: return "RPC_NT_NOT_CANCELLED";
        case RPC_NT_INVALID_ASYNC_HANDLE: return "RPC_NT_INVALID_ASYNC_HANDLE";
        case RPC_NT_INVALID_ASYNC_CALL: return "RPC_NT_INVALID_ASYNC_CALL";
        case RPC_NT_PROXY_ACCESS_DENIED: return "RPC_NT_PROXY_ACCESS_DENIED";
        case RPC_NT_SEND_INCOMPLETE: return "RPC_NT_SEND_INCOMPLETE";
        case RPC_NT_NO_MORE_ENTRIES: return "RPC_NT_NO_MORE_ENTRIES";
        case RPC_NT_SS_CHAR_TRANS_OPEN_FAIL: return "RPC_NT_SS_CHAR_TRANS_OPEN_FAIL";
        case RPC_NT_SS_CHAR_TRANS_SHORT_FILE: return "RPC_NT_SS_CHAR_TRANS_SHORT_FILE";
        case RPC_NT_SS_IN_NULL_CONTEXT: return "RPC_NT_SS_IN_NULL_CONTEXT";
        case RPC_NT_SS_CONTEXT_MISMATCH: return "RPC_NT_SS_CONTEXT_MISMATCH";
        case RPC_NT_SS_CONTEXT_DAMAGED: return "RPC_NT_SS_CONTEXT_DAMAGED";
        case RPC_NT_SS_HANDLES_MISMATCH: return "RPC_NT_SS_HANDLES_MISMATCH";
        case RPC_NT_SS_CANNOT_GET_CALL_HANDLE: return "RPC_NT_SS_CANNOT_GET_CALL_HANDLE";
        case RPC_NT_NULL_REF_POINTER: return "RPC_NT_NULL_REF_POINTER";
        case RPC_NT_ENUM_VALUE_OUT_OF_RANGE: return "RPC_NT_ENUM_VALUE_OUT_OF_RANGE";
        case RPC_NT_BYTE_COUNT_TOO_SMALL: return "RPC_NT_BYTE_COUNT_TOO_SMALL";
        case RPC_NT_BAD_STUB_DATA: return "RPC_NT_BAD_STUB_DATA";
        case RPC_NT_INVALID_ES_ACTION: return "RPC_NT_INVALID_ES_ACTION";
        case RPC_NT_WRONG_ES_VERSION: return "RPC_NT_WRONG_ES_VERSION";
        case RPC_NT_WRONG_STUB_VERSION: return "RPC_NT_WRONG_STUB_VERSION";
        case RPC_NT_INVALID_PIPE_OBJECT: return "RPC_NT_INVALID_PIPE_OBJECT";
        case RPC_NT_INVALID_PIPE_OPERATION: return "RPC_NT_INVALID_PIPE_OPERATION";
        case RPC_NT_WRONG_PIPE_VERSION: return "RPC_NT_WRONG_PIPE_VERSION";
        case RPC_NT_PIPE_CLOSED: return "RPC_NT_PIPE_CLOSED";
        case RPC_NT_PIPE_DISCIPLINE_ERROR: return "RPC_NT_PIPE_DISCIPLINE_ERROR";
        case RPC_NT_PIPE_EMPTY: return "RPC_NT_PIPE_EMPTY";
        default: return tempstr_printf("Unknown (0x%"PRIx32")", status);
    }
}

static char const *cifs_id_2_str(struct cifs_proto_info const *info)
{
    switch (info->version) {
        case SMB_VERSION_1:
            return tempstr_printf("%"PRIu16, info->ids.multiplex_id);
        case SMB_VERSION_2:
        case SMB_VERSION_3:
            return tempstr_printf("%"PRIu64, info->ids.message_id);
        default:
            return "Incorrect version";
    }
}

bool cifs_has_flag_file(struct cifs_proto_info const *info)
{
    return info->version == 1 && info->command.smb_command == SMB_COM_TRANSACTION2
        && info->subcommand.trans2_subcmd == SMB_TRANS2_SET_PATH_INFORMATION;
}

static char const *cifs_info_2_str(struct proto_info const *info_)
{
    struct cifs_proto_info const *info = DOWNCAST(info_, info, cifs_proto_info);
    bool has_flag_file = cifs_has_flag_file(info);
    char *str = tempstr_printf("%s, version=%s, command=%s, status=%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s, tree_id=%"PRIu32", id=%s, query_write_bytes=%"PRIu32", response_read_bytes=%"PRIu32", response_write_bytes=%"PRIu32", meta_read_bytes=%"PRIu32", meta_write_bytes=%"PRIu32,
            proto_info_2_str(info_),
            info->version == 1 ? "SMB1" : "SMB2",
            info->version == 1 ? smb_command_2_str(info->command.smb_command) :
                smb2_command_2_str(info->command.smb2_command),
            smb_status_2_str(info->status),
            info->set_values & CIFS_DOMAIN ? ", domain=" : "",
            info->set_values & CIFS_DOMAIN ? info->domain : "",
            info->set_values & CIFS_USER ? ", user=" : "",
            info->set_values & CIFS_USER ? info->user : "",
            info->set_values & CIFS_TREE ? ", tree=" : "",
            info->set_values & CIFS_TREE ? info->tree : "",
            info->set_values & CIFS_PATH ? ", path=" : "",
            info->set_values & CIFS_PATH ? info->path : "",
            info->set_values & CIFS_TRANS2_SUBCMD ? ", trans2_subcmd=" : "",
            info->set_values & CIFS_TRANS2_SUBCMD ? smb_trans2_subcmd_2_str(info->subcommand.trans2_subcmd) : "",
            info->set_values & CIFS_TRANSACTION_SUBCMD ? ", transaction_subcmd=" : "",
            info->set_values & CIFS_TRANSACTION_SUBCMD ? smb_transaction_subcmd_2_str(info->subcommand.transaction_subcmd) : "",
            info->set_values & CIFS_NT_TRANSACT_SUBCMD ? ", nt_transact_subcommand=" : "",
            info->set_values & CIFS_NT_TRANSACT_SUBCMD ? smb_nt_trans_subcmd_2_str(info->subcommand.nt_transact_subcmd) : "",
            info->set_values & CIFS_LEVEL_OF_INTEREST ? ", level_of_interest=" : "",
            info->set_values & CIFS_LEVEL_OF_INTEREST ? smb_file_info_levels_2_str(info->level_of_interest) : "",
            info->set_values & CIFS_FID ? ", fid=" : "",
            info->set_values & CIFS_FID ? tempstr_printf("0x%"PRIx64, info->fid) : "",
            has_flag_file && info->parameters.flag_file &  CIFS_FILE_CREATE ? ", creation" : "",
            has_flag_file && info->parameters.flag_file &  CIFS_FILE_DIRECTORY ? ", directory" : "",
            has_flag_file && info->parameters.flag_file &  CIFS_FILE_UNLINK ? ", unlink" : "",
            info->is_query ? ", query" : "",
            info->tree_id,
            cifs_id_2_str(info),
            info->query_write_bytes, info->response_read_bytes,
            info->response_write_bytes, info->meta_read_bytes, info->meta_write_bytes);
    return str;
}

struct smb_hdr {
    uint32_t code;      // Must contains 0xff 'SMB'
    uint8_t command;
    uint32_t status;

    uint8_t flags;
    uint16_t flags2;

    uint16_t process_id_high;
    uint64_t signature;
    uint16_t reserved;
    uint16_t tree_id;
    uint16_t process_id;
    uint16_t user_id;
    uint16_t multiplex_id;
} packed_;

#define   SMB2_FLAGS_SERVER_TO_REDIR      0x00000001
#define   SMB2_FLAGS_ASYNC_COMMAND        0x00000002
#define   SMB2_FLAGS_RELATED_OPERATIONS   0x00000004
#define   SMB2_FLAGS_SIGNED               0x00000008
#define   SMB2_FLAGS_DFS_OPERATIONS       0x10000000
#define   SMB2_FLAGS_REPLAY_OPERATION     0x20000000

struct smb2_hdr {
    uint32_t code;              // Must contains 0xfe 'SMB'
    uint16_t structure_size;
    uint16_t credit_charge;
    union {
        struct smb_sequence {
            uint16_t channel_sequence;
            uint16_t reserved;
        } seq;
        uint32_t status;
    } u1;
    uint16_t command;
    uint16_t credit;
    uint32_t flags;
    uint32_t next_command;
    uint64_t message_id;
    union {
        struct async {
            uint64_t async_id;
        } async;
        struct sync {
            uint32_t reserved;
            uint32_t tree_id;
        } sync;
    } u2;
    uint64_t session_id;
    uint64_t signatures[2];
} packed_;

/*
 * Parser
 */

static pthread_key_t iconv_pthread_key;

static iconv_t get_iconv()
{
    iconv_t iconv_cd = pthread_getspecific(iconv_pthread_key);
    if (iconv_cd == NULL) {
        iconv_cd = iconv_open("UTF8//IGNORE", "UTF16LE");
        assert(iconv_cd != (iconv_t)-1);
        pthread_setspecific(iconv_pthread_key, (void *)iconv_cd);
    }
    return iconv_cd;
}

struct cifs_parser {
    struct parser parser;
    bool unicode;
    uint16_t level_of_interest;
    union subcommand {
        enum smb_trans2_subcommand trans2_subcmd;
        enum smb_nt_transact_subcommand nt_trans_subcmd;
        enum smb_transaction_subcommand transaction_subcmd;
    } subcommand;
};

static const char *cifs_parser_2_str(struct cifs_parser const *cifs_parser)
{
    char *str = tempstr_printf("Parser @%p, unicode: %d, level_of_interest: %s",
            cifs_parser, cifs_parser->unicode,
            smb_file_info_levels_2_str(cifs_parser->level_of_interest));
    return str;
}

static int cifs_parser_ctor(struct cifs_parser *cifs_parser, struct proto *proto)
{
    SLOG(LOG_DEBUG, "Constructing cifs_parser@%p", cifs_parser);
    assert(proto == proto_cifs);
    if (0 != parser_ctor(&cifs_parser->parser, proto)) return -1;
    cifs_parser->unicode = true;
    cifs_parser->level_of_interest = 0;
    cifs_parser->subcommand.trans2_subcmd = 0;
    return 0;
}

static struct parser *cifs_parser_new(struct proto *proto)
{
    struct cifs_parser *cifs_parser = objalloc_nice(sizeof(*cifs_parser), "cifs parsers");
    if (! cifs_parser) return NULL;
    if (-1 == cifs_parser_ctor(cifs_parser, proto)) {
        objfree(cifs_parser);
        return NULL;
    }
    return &cifs_parser->parser;
}

static void cifs_parser_dtor(struct cifs_parser *cifs_parser)
{
    SLOG(LOG_DEBUG, "Destructing cifs_parser@%p", cifs_parser);
    parser_dtor(&cifs_parser->parser);
}

static void cifs_parser_del(struct parser *parser)
{
    struct cifs_parser *cifs_parser = DOWNCAST(parser, parser, cifs_parser);
    cifs_parser_dtor(cifs_parser);
    objfree(cifs_parser);
}

// Parse helpers

static void const *cifs_info_addr(struct proto_info const *info_, size_t *size)
{
    struct cifs_proto_info const *info = DOWNCAST(info_, info, cifs_proto_info);
    if (size) *size = sizeof(*info);
    return info;
}

static void cifs_proto_info_ctor(struct cifs_proto_info *info, struct parser *parser,
        struct proto_info *parent, size_t header, size_t payload, bool is_query,
        enum smb_version version, struct timeval const *first_packet_tv)
{
    memset(info, 0, sizeof(*info));
    proto_info_ctor(&info->info, parser, parent, header, payload);
    info->is_query = is_query;
    info->version = version;
    info->first_packet_tv = *first_packet_tv;
}

/*
 * Can be either uchar or unicode (utf-16le) depending on capabilities in negociate response
 * It must be 16-bit aligned.
 * @return number of read bytes from cursor
 */
static int parse_smb_string(struct cifs_parser *cifs_parser, struct cursor *cursor,
        char *buf, int buf_size)
{
    int ret = 0;
    if (!cifs_parser->unicode) {
        ret = cursor_read_string(cursor, buf, buf_size, cursor->cap_len);
    } else {
        if (cursor->cap_len > 3 && cursor->head[1] != 0x00 && cursor->head[2] == 0x00) {
            SLOG(LOG_DEBUG, "Skipping some bytes to align utf16");
            cursor_drop(cursor, 1);
        }
        ret = cursor_read_utf16(cursor, get_iconv(), buf, buf_size, cursor->cap_len);
    }
    SLOG(LOG_DEBUG, "Parse smb string as %sunicode: %s", cifs_parser->unicode ? "" : "non-",
            ret > 0 ? buf : "error");
    return ret;
}

static int parse_and_check_word_count(struct cursor *cursor, uint8_t expected_word_count)
{
    if (expected_word_count == 0xff) return -1;
    uint8_t total_expected = expected_word_count + 1;
    if (cursor->cap_len < total_expected) {
        SLOG(LOG_DEBUG, "Expected word count of %"PRIu8", cap_len too small %zu",
                total_expected, cursor->cap_len);
        return -1;
    }
    uint8_t word_count = cursor_read_u8(cursor);
    if (expected_word_count != word_count) {
        SLOG(LOG_DEBUG, "Expected word count of 0x%02"PRIx8", got 0x%02"PRIx8, expected_word_count, word_count);
        return -1;
    }
    return word_count;
}

static int parse_and_check_word_count_superior_or_equal(struct cursor *cursor, uint8_t minimum_word_count)
{
    if (minimum_word_count == 0xff) return -1;
    uint8_t total_minimum = minimum_word_count + 1;
    if (cursor->cap_len < total_minimum) return -1;
    uint8_t word_count = cursor_read_u8(cursor);
    if (word_count < minimum_word_count) {
        SLOG(LOG_DEBUG, "Expected word count should be >= 0x%02"PRIx8", got 0x%02"PRIx8, minimum_word_count, word_count);
        return -1;
    }
    return word_count;
}

static int parse_and_check_byte_count_superior_or_equal(struct cursor *cursor, uint16_t minimum_byte_count)
{
    if (cursor->cap_len < 2) return -1;
    uint16_t byte_count = cursor_read_u16le(cursor);
    SLOG(LOG_DEBUG, "Byte count is 0x%"PRIx16, byte_count);
    if (byte_count < minimum_byte_count) {
        SLOG(LOG_DEBUG, "Byte count is too small  (0x%02"PRIx16" > 0x%02"PRIx16")", minimum_byte_count, byte_count);
        return -1;
    }
    /*if (cursor->cap_len < byte_count) {*/
        /*SLOG(LOG_DEBUG, "Cursor buffer too small (0x%02"PRIx16" > %zu)", minimum_byte_count, cursor->cap_len);*/
        /*return -1;*/
    /*}*/
    return byte_count;
}

// Parse of security buffer

enum mech_type { MS_KRB5, NTLMSSP };

static bool der_application_equal(struct der const *der, int application)
{
    return (der->class_identifier == DER_APPLICATION
            && der->type == DER_CONSTRUCTED
            && der->class_tag == application);
}

static bool der_choice_equal(struct der const *der, int choice)
{
    return ((der->class_identifier == DER_UNIVERSAL || der->class_identifier == DER_CONTEXT_SPECIFIC)
            && der->type == DER_CONSTRUCTED
            && der->class_tag == choice);
}

static const struct der sequence_der = {.class_identifier = DER_UNIVERSAL, .type = DER_CONSTRUCTED,
    .class_tag = DER_SEQUENCE };
static const struct der oid_der = {.class_identifier = DER_UNIVERSAL, .type = DER_PRIMITIVE,
    .class_tag = DER_OBJECT_IDENTIFIER };
static const struct der octet_string_der = {.class_identifier = DER_UNIVERSAL, .type = DER_PRIMITIVE,
    .class_tag = DER_OCTET_STRING };

#define PARSE_DER_APPLICATION(ID) \
    if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status; \
    if (!der_application_equal(&der, ID)) return PROTO_PARSE_ERR;

#define PARSE_DER_OID() \
    if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status; \
    if (!der_type_equal(&der, &oid_der)) return PROTO_PARSE_ERR; \
    cursor_read_oid(cursor, der.length, oid, NULL); \

#define PARSE_DER_OCTET_STRING() \
    if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status; \
    if (!der_type_equal(&der, &octet_string_der)) return PROTO_PARSE_ERR;

#define PARSE_DER_SEQUENCE() \
    if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status; \
    if (!der_type_equal(&der, &sequence_der)) return PROTO_PARSE_ERR;

#define PARSE_DER_UNTIL_CHOICE_ID(ID) \
    do { \
        if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status; \
        if (der_choice_equal(&der, ID)) break; \
        else cursor_drop(cursor, der.length); \
    } while (cursor->cap_len > 0); \
    if (cursor->cap_len == 0) return PROTO_PARSE_ERR; \

#define PARSE_DER_CHOICE_ID(ID) \
    if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status; \
    if (!der_choice_equal(&der, ID)) return PROTO_PARSE_ERR;

#define DROP_DER() \
    if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status; \
    cursor_drop(cursor, der.length);

enum ntlm_message_type {
    NTLMSSP_NEGOCIATE = 0x1,
    NTLMSSP_CHALLENGE,
    NTLMSSP_AUTHENTICATE,
};

/**
 * NTLM message
 *
 * | Signature | Message type |
 * | 8 bytes   | 4 bytes      |
 *
 * Body payload depends of message type
 * For NTLMSSP_AUTHENTICATE:
 *
 * | LmChallengeResponseFields       | NtChallengeResponseFields | DomainNameFields | UserNameFields | WorkstationFields |
 * | 8 bytes                         | 8 bytes                   | 8 bytes          | 8 bytes        | 8 bytes           |
 *
 * | EncryptedRandomSessionKeyFields | NegotiateFlags            | Version          | MIC            | Payload           |
 * | 8 bytes                         | 4 bytes                   | 8 bytes          | 16 bytes       | variable          |
 *
 */
static enum proto_parse_status parse_ntlm_request_message(struct cursor *cursor, struct cifs_proto_info *info)
{
    uint8_t const *start = cursor->head;
    CHECK(8 + 4);
    char buf[8];
#define CIFS_NTLMSSP_ID "NTLMSSP"
    if (-1 == cursor_read_string(cursor, buf, sizeof(buf), sizeof(CIFS_NTLMSSP_ID)))
        return PROTO_PARSE_ERR;
    if (0 != strcmp(buf, CIFS_NTLMSSP_ID)) {
        SLOG(LOG_DEBUG, "Expected %s as ntlm id, got %s", CIFS_NTLMSSP_ID, buf);
        return PROTO_PARSE_ERR;
    }

    enum ntlm_message_type message_type = cursor_read_u32le(cursor);
    SLOG(LOG_DEBUG, "Found an ntlm message of type %"PRIu32, message_type);
    if (message_type != NTLMSSP_AUTHENTICATE) {
        // nothing interesting to fetch
        return PROTO_OK;
    }

    CHECK(8 * 6 + 4 + 8 + 16);
    cursor_drop(cursor, 8 + 8);

    uint16_t domain_length = cursor_read_u16le(cursor);
    cursor_drop(cursor, 2);
    uint32_t domain_offset = cursor_read_u32le(cursor);
    uint16_t user_length = cursor_read_u16le(cursor);
    cursor_drop(cursor, 2);
    uint32_t user_offset = cursor_read_u32le(cursor);
    uint16_t workstation_length = cursor_read_u16le(cursor);
    cursor_drop(cursor, 2);
    uint32_t workstation_offset = cursor_read_u32le(cursor);

    assert(workstation_offset == (user_offset + user_length));

    size_t current_position = cursor->head - start;
    CHECK(workstation_offset + workstation_length - current_position);
    cursor_drop(cursor, domain_offset - current_position);
    if (-1 == cursor_read_fixed_utf16(cursor, get_iconv(), info->domain, sizeof(info->domain), domain_length))
        return PROTO_PARSE_ERR;
    info->set_values |= CIFS_DOMAIN;
    SLOG(LOG_DEBUG, "Parsed domain %s", info->domain);
    if (-1 == cursor_read_fixed_utf16(cursor, get_iconv(), info->user, sizeof(info->user), user_length))
        return PROTO_PARSE_ERR;
    info->set_values |= CIFS_USER;
    SLOG(LOG_DEBUG, "Parsed user %s", info->user);
    if (-1 == cursor_read_fixed_utf16(cursor, get_iconv(), info->hostname, sizeof(info->hostname), workstation_length))
        return PROTO_PARSE_ERR;
    info->set_values |= CIFS_HOSTNAME;
    SLOG(LOG_DEBUG, "Parsed hostname %s", info->hostname);

    return PROTO_OK;
}

static uint32_t krb5_oid[] = {1, 2, 840, 48018, 1, 2, 2};
static uint32_t ntlmssp_oid[] = {1, 3, 6, 1, 4, 1, 311, 2, 2, 10};

/**
 * AP-REQ ::= [APPLICATION 14] SEQUENCE {
 *         pvno [0]        INTEGER,        -- indicates Version 5
 *         msg-type [1]    INTEGER,        -- indicates KRB_AP_REQ
 *         ap-options[2]   APOptions,
 *         ticket[3]       Ticket,
 *         authenticator[4]        EncryptedData
 * }
 *
 * APOptions ::= BIT STRING {
 *         reserved (0),
 *         use-session-key (1),
 *         mutual-required (2)
 * }
 *
 * Ticket ::= [APPLICATION 1] SEQUENCE {
 *         tkt-vno [0]     INTEGER,        -- indicates Version 5
 *         realm [1]       Realm,
 *         sname [2]       PrincipalName,
 *         enc-part [3]    EncryptedData
 * }
 *
 * -- Encrypted part of ticket
 * EncTicketPart ::= [APPLICATION 3] SEQUENCE {
 *         flags[0]        TicketFlags,
 *         key[1]          EncryptionKey,
 *         crealm[2]       Realm,
 *         cname[3]        PrincipalName,
 *         transited[4]    TransitedEncoding,
 *         authtime[5]     KerberosTime,
 *         starttime[6]    KerberosTime OPTIONAL,
 *         endtime[7]      KerberosTime,
 *         renew-till[8]   KerberosTime OPTIONAL,
 *         caddr[9]        HostAddresses OPTIONAL,
 *         authorization-data[10]  AuthorizationData OPTIONAL
 * }
 *
 * -- Unencrypted authenticator
 * Authenticator ::= [APPLICATION 2] SEQUENCE  {
 *         authenticator-vno[0]    INTEGER,
 *         crealm[1]               Realm,
 *         cname[2]                PrincipalName,
 *         cksum[3]                Checksum OPTIONAL,
 *         cusec[4]                INTEGER,
 *         ctime[5]                KerberosTime,
 *         subkey[6]               EncryptionKey OPTIONAL,
 *         seq-number[7]           INTEGER OPTIONAL,
 *         authorization-data[8]   AuthorizationData OPTIONAL
 * }
 */
static enum proto_parse_status parse_krb5_blob(struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parsing krb5 blob");
    enum proto_parse_status status;
    struct der der;
    uint32_t oid[10];
    // krb5 application
    PARSE_DER_APPLICATION(0);
    // Mech type
    PARSE_DER_OID();
    if (!memcmp(oid, krb5_oid, sizeof(krb5_oid))) return PROTO_PARSE_ERR;
    // 2 bytes token id
    uint16_t tok_id = cursor_read_u16le(cursor);
    SLOG(LOG_DEBUG, "Found tok id %"PRIu16, tok_id);
    if (tok_id == 1) {
        // KRB_AP_REQ (application 14)
        PARSE_DER_APPLICATION(14);
        PARSE_DER_SEQUENCE();
        // pvno
        PARSE_DER_CHOICE_ID(0);
        DROP_DER();
        // msg-type
        PARSE_DER_CHOICE_ID(1);
        DROP_DER();
        // ap-options
        PARSE_DER_CHOICE_ID(2);
        DROP_DER();
       // ticket (Sequence id 3) (application 1)
        PARSE_DER_CHOICE_ID(3);
        PARSE_DER_APPLICATION(1);
        PARSE_DER_SEQUENCE();
        // tkt_vno
        PARSE_DER_CHOICE_ID(0);
        DROP_DER();
        // Realm
        PARSE_DER_CHOICE_ID(1);
        if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status;
        cursor_read_fixed_string(cursor, info->domain, sizeof(info->domain), der.length);
        info->set_values |= CIFS_DOMAIN;
    } else if (tok_id == 2) {
        // KRB_AP_REP
    } else if (tok_id == 3) {
        // KRB_ERROR
    } else {
        return PROTO_PARSE_ERR;
    }
    return PROTO_OK;
}

/**
 * NegTokenInit ::= SEQUENCE {
 *                             mechTypes       [0] MechTypeList  OPTIONAL,
 *                             reqFlags        [1] ContextFlags  OPTIONAL,
 *                             mechToken       [2] OCTET STRING  OPTIONAL,
 *                             mechListMIC     [3] OCTET STRING  OPTIONAL
 *                          }
 */
static enum proto_parse_status parse_neg_token_init(struct cursor *cursor, struct cifs_proto_info *info)
{
    enum proto_parse_status status;
    struct der der;
    uint32_t oid[10];

    PARSE_DER_SEQUENCE();
    // MechTypeList
    PARSE_DER_CHOICE_ID(0);
    struct der mech_type_list_der = der;
    PARSE_DER_SEQUENCE();
    PARSE_DER_OID();

    // Skip the rest of mech lists
    size_t delta = cursor->head - mech_type_list_der.value;
    if (mech_type_list_der.length < delta) return PROTO_PARSE_ERR;
    cursor_drop(cursor, mech_type_list_der.length - delta);

    // We Sequence identifier for mech token
    PARSE_DER_UNTIL_CHOICE_ID(2);

    // Mech token
    if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status;
    if (!der_type_equal(&der, &octet_string_der)) return PROTO_PARSE_ERR;

    if (memcmp(oid, ntlmssp_oid, sizeof(ntlmssp_oid)) == 0) {
        SLOG(LOG_DEBUG, "Found a ntlmssp mech type");
        return parse_ntlm_request_message(cursor, info);
    } else if (memcmp(oid, krb5_oid, sizeof(krb5_oid)) == 0) {
        SLOG(LOG_DEBUG, "Found a krb5 mech type");
        return parse_krb5_blob(cursor, info);
    } else {
        SLOG(LOG_DEBUG, "Unknown mech type oid");
    }
    return PROTO_OK;
}

/**
 * Security buffer encoded in der.
 * Contains a gss-api message.
 * The gss-api message contains an SPNEGO message
 * The SPNEGO can use ntlm or krb5 mechanism type
 *
 * NegotiationToken ::= CHOICE {
 *                               negTokenInit  [0]  NegTokenInit,
 *                               negTokenTarg  [1]  NegTokenTarg }
 *
 * MechTypeList ::= SEQUENCE OF MechType
 *
 * NegTokenTarg ::= SEQUENCE {
 *     negResult      [0] ENUMERATED {
 *                             accept_completed    (0),
 *                             accept_incomplete   (1),
 *                             reject              (2) }          OPTIONAL,
 *     supportedMech  [1] MechType                                OPTIONAL,
 *     responseToken  [2] OCTET STRING                            OPTIONAL,
 *     mechListMIC    [3] OCTET STRING                            OPTIONAL
 * }
 **/
static enum proto_parse_status parse_security_buffer(struct cursor *cursor, struct cifs_proto_info *info)
{
    enum proto_parse_status status;

    struct der der;
    if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status;
    // Gss api or negtokentarg
    if (der_application_equal(&der, 0)) {
        SLOG(LOG_DEBUG, "Got a Gss api");
        uint32_t oid[10];
        static uint32_t spnego_oid[] = {1, 3, 6, 1, 5, 5, 2};
        PARSE_DER_OID();
        if (memcmp(oid, spnego_oid, sizeof(spnego_oid)) != 0) return PROTO_PARSE_ERR;

        // Advance neg token init choice
        if (PROTO_OK != (status = cursor_read_der(cursor, &der))) return status;
        if (der_choice_equal(&der, 0)) {
            return parse_neg_token_init(cursor, info);
        }
        return PROTO_OK;
    } else if (der_choice_equal(&der, 1)) {
        SLOG(LOG_DEBUG, "Got a NegTokenTarg");
        PARSE_DER_SEQUENCE();
        PARSE_DER_UNTIL_CHOICE_ID(2);
        PARSE_DER_OCTET_STRING();
        return parse_ntlm_request_message(cursor, info);
    } else {
        return PROTO_PARSE_ERR;
    }
}

// Parse functions

#define PARSE_SMB_OS(info, way) \
    CHECK(2);\
    if (parse_smb_string(cifs_parser, cursor, info->os, sizeof(info->os)) < 0) \
        return PROTO_PARSE_ERR; \
    info->set_values |= way == FROM_CLIENT ? CIFS_OS : CIFS_SERVER_OS;

#define PARSE_SMB_DRIVER(info, way) \
    CHECK(2);\
    if (parse_smb_string(cifs_parser, cursor, info->driver, sizeof(info->driver)) < 0) \
        return PROTO_PARSE_ERR; \
    info->set_values |= way == FROM_CLIENT ? CIFS_DRIVER : CIFS_SERVER_DRIVER;

#define PARSE_SMB_DOMAIN(info) \
    CHECK(2);\
    if (parse_smb_string(cifs_parser, cursor, info->domain, sizeof(info->domain)) < 0) \
        return PROTO_PARSE_ERR; \
    info->set_values |= CIFS_DOMAIN;

#define PARSE_SMB_USER(info) \
    CHECK(2);\
    if (parse_smb_string(cifs_parser, cursor, info->user, sizeof(info->user)) < 0) \
        return PROTO_PARSE_ERR; \
    info->set_values |= CIFS_USER;

#define PARSE_SMB_PATH(info) \
    CHECK(2);\
    if (parse_smb_string(cifs_parser, cursor, info->path, sizeof(info->path)) < 0) \
        return PROTO_PARSE_ERR; \
    info->set_values |= CIFS_PATH;

#define PARSE_SMB2_PATH(info, length) \
    if (cursor_read_fixed_utf16(cursor, get_iconv(), info->path, sizeof(info->path), length) < 0) \
        return PROTO_PARSE_ERR; \
    info->set_values |= CIFS_PATH;

#define PARSE_SMB2_TREE(info, length) \
    if (cursor_read_fixed_utf16(cursor, get_iconv(), info->tree, sizeof(info->tree), length) < 0) \
        return PROTO_PARSE_ERR; \
    info->set_values |= CIFS_TREE;

#define PARSE_SMB2_FID(info) \
    uint64_t fid = cursor_read_u64le(cursor);\
    cursor_drop(cursor, 8); \
    if (fid != 0xffffffffffffffff) cifs_set_fid(info, fid);

#define CHECK_AND_DROP_WITH_PADDING(NUM_BYTES) \
        CHECK_AND_DROP(NUM_BYTES + compute_padding(cifs_parser, cursor, NUM_BYTES, 2));


/*
 * Negociate response:
 * Word count: 0x11
 *
 * Parameters
 * | USHORT        | UCHAR         | USHORT      | USHORT       | ULONG         | ULONG      | ULONG      | ULONG        | 8 bytes    | USHORT         | UCHAR           |
 * | Dialect Index | Security mode | MaxMpxCount | MaxNumberVcs | MaxBufferSize | MaxRawSize | SessionKey | Capabilities | SystemTime | ServerTimeZone | ChallengeLength |
 *
 * Data
 * | <Challenge length> bytes | smb string |
 * | Challenge                | domain     |
 */
static enum proto_parse_status parse_negociate_response(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse of negociate query");
    // We are only interested in negociate response
    if (parse_and_check_word_count(cursor, 0x11) == -1) return PROTO_PARSE_ERR;
    // Reach challenge length
    cursor_drop(cursor, 33);

    uint8_t challenge_length = cursor_read_u8(cursor);
    int byte_count = parse_and_check_byte_count_superior_or_equal(cursor, challenge_length);
    if (byte_count == -1) return PROTO_PARSE_ERR;
    else if (byte_count > 50) {
        static uint8_t spnego_oid[6] = {0x2b, 0x06, 0x01, 0x05, 0x05, 0x02};
        if (cursor_lookup_marker(cursor, spnego_oid, sizeof(spnego_oid), cursor->cap_len)) {
            return PROTO_OK; // Should be a security blob from ntlm 0.12, ignore it
        }
    }
    cursor_drop(cursor, challenge_length);

    PARSE_SMB_DOMAIN(info);
    SLOG(LOG_DEBUG, "Found domain %s", info->domain);

    return PROTO_OK;
}

static size_t compute_padding(struct cifs_parser *cifs_parser, struct cursor *cursor,
        uint8_t offset, size_t alignment)
{
    return cifs_parser->unicode ? (cursor->cap_len - offset) % alignment : 0;
}

/*
 * Session setup query 0x0d version
 *
 * Parameters
 * | 4 bytes | USHORT        | USHORT      | USHORT   | ULONG      | USHORT         | USHORT             | ULONG    | ULONG        |
 * | Andx    | MaxBufferSize | MaxMpxCount | VcNumber | SessionKey | OEMPasswordLen | UnicodePasswordLen | Reserved | Capabilities |
 *
 * Data
 * | UCHAR         | UCHAR             | UCHAR | SMB_STRING    | SMB_STRING      | SMB_STRING | SMB_STRING     |
 * | OEMPassword[] | UnicodePassword[] | Pad[] | AccountName[] | PrimaryDomain[] | NativeOS[] | NativeLanMan[] |
 */
static enum proto_parse_status parse_session_setup_andx_query_normal(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    cursor_drop(cursor, 14);
    uint16_t oem_password_len = cursor_read_u16le(cursor);
    uint16_t unicode_password_len = cursor_read_u16le(cursor);
    cursor_drop(cursor, 8);

    uint8_t padding = compute_padding(cifs_parser, cursor, oem_password_len + unicode_password_len, 2);
    if (parse_and_check_byte_count_superior_or_equal(cursor, oem_password_len + unicode_password_len + padding) == -1) return PROTO_PARSE_ERR;
    SLOG(LOG_DEBUG, "Padding of %d", padding);
    cursor_drop(cursor, oem_password_len + unicode_password_len + padding);
    PARSE_SMB_USER(info);
    SLOG(LOG_DEBUG, "Found user %s", info->user);
    PARSE_SMB_DOMAIN(info);
    SLOG(LOG_DEBUG, "Found domain %s", info->domain);
    PARSE_SMB_OS(info, FROM_CLIENT);
    SLOG(LOG_DEBUG, "Found os %s", info->os);
    PARSE_SMB_DRIVER(info, FROM_CLIENT);
    SLOG(LOG_DEBUG, "Found driver %s", info->driver);
    return PROTO_OK;
}

/*
 * Session setup query, security blob version
 *
 * Parameters
 * | 4 bytes | USHORT        | USHORT      | USHORT   | ULONG      | USHORT               | ULONG    | ULONG        |
 * | Andx    | MaxBufferSize | MaxMpxCount | VcNumber | SessionKey | Security Blob length | Reserved | Capabilities |
 *
 * Data
 * | Variable      | SMB_STRING | SMB_STRING     |
 * | Security blob | NativeOS[] | NativeLanMan[] |
 */
static enum proto_parse_status parse_session_setup_andx_query_security_blob(struct cursor *cursor,
        struct cifs_proto_info *info)
{
    cursor_drop(cursor, 14);
    uint16_t security_blob_length = cursor_read_u16le(cursor);
    cursor_drop(cursor, 8);
    // Check if we have padding here
    int byte_count = parse_and_check_byte_count_superior_or_equal(cursor, security_blob_length);
    if (byte_count == -1) return PROTO_PARSE_ERR;
    return parse_security_buffer(cursor, info);
}

/*
 * Session setup query
 * Word count: 0x0d for normal version, 0x0c for security blob version
 */
static enum proto_parse_status parse_session_setup_andx_query(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse of setup query");
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x0c);
    if (word_count == 0x0d) return parse_session_setup_andx_query_normal(cifs_parser, cursor, info);
    else if (word_count == 0x0c) return parse_session_setup_andx_query_security_blob(cursor, info);
    return PROTO_PARSE_ERR;
}

/*
 * Session setup query, normal version
 *
 * Parameters
 * | 4 bytes | USHORT |
 * | Andx    | Action |
 *
 * Data
 * | UCHAR | SMB_STRING | SMB_STRING     | SMB_STRING      |
 * | Pad[] | NativeOS[] | NativeLanMan[] | PrimaryDomain[] |
 */
static enum proto_parse_status parse_session_setup_andx_response_normal(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    cursor_drop(cursor, 0x03 * 2);
    if (parse_and_check_byte_count_superior_or_equal(cursor, 0) == -1) return PROTO_PARSE_ERR;
    uint8_t padding = compute_padding(cifs_parser, cursor, 0, 2);
    CHECK_AND_DROP(padding);
    PARSE_SMB_OS(info, FROM_SERVER);
    SLOG(LOG_DEBUG, "Found os %s", info->os);
    PARSE_SMB_DRIVER(info, FROM_SERVER);
    SLOG(LOG_DEBUG, "Found driver %s", info->driver);
    PARSE_SMB_DOMAIN(info);
    SLOG(LOG_DEBUG, "Found domain %s", info->domain);
    return PROTO_OK;
}

/*
 * Session setup response, security blob version
 *
 * Parameters
 * | 4 bytes | USHORT | USHORT               |
 * | Andx    | Action | Security blob length |
 *
 * Data
 * | Variable      | SMB_STRING | SMB_STRING     |
 * | Security blob | NativeOS[] | NativeLanMan[] |
 */
static enum proto_parse_status parse_session_setup_andx_response_security_blob(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    cursor_drop(cursor, 4 + 2);
    uint16_t blob_length = cursor_read_u16le(cursor);
    if (parse_and_check_byte_count_superior_or_equal(cursor, blob_length + 2) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, blob_length);
    PARSE_SMB_OS(info, FROM_SERVER);
    SLOG(LOG_DEBUG, "Found os %s", info->os);
    PARSE_SMB_DRIVER(info, FROM_SERVER);
    SLOG(LOG_DEBUG, "Found driver %s", info->driver);
    return PROTO_OK;
}

/*
 * Session setup response
 *
 * Word count: 0x03 for normal version, 0x04 for security blob
 */
static enum proto_parse_status parse_session_setup_andx_response(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse of setup response");
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x03);
    if (word_count == 0x03) return parse_session_setup_andx_response_normal(cifs_parser, cursor, info);
    else if (word_count == 0x04) return parse_session_setup_andx_response_security_blob(cifs_parser, cursor, info);
    else return PROTO_PARSE_ERR;
}

/*
 * Tree connect andX query
 * Word count: 0x04
 *
 * Parameters
 * | 4 bytes | USHORT | USHORT         |
 * | Andx    | Flags  | PasswordLength |
 *
 * Data
 * | UCHAR                    | UCHAR | SMB_STRING | OEM_STRING |
 * | Password[PasswordLength] | Pad[] | Path       | Service    |
 */
static enum proto_parse_status parse_tree_connect_andx_request_query(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse Tree connect and request query");
    if (parse_and_check_word_count(cursor, 0x04) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 6);
    uint16_t password_len = cursor_read_u16le(cursor);

    uint8_t padding = compute_padding(cifs_parser, cursor, password_len + 2, 2);
    if (parse_and_check_byte_count_superior_or_equal(cursor, password_len + padding) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, password_len + padding);
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

static enum proto_parse_status drop_parameter_padding(struct cursor *cursor, size_t header_size, uint8_t const *start_cursor, uint8_t parameter_offset)
{
    size_t pos = header_size + cursor->head - start_cursor;
    if (pos > parameter_offset) {
        SLOG(LOG_DEBUG, "Position is greater than parameter offset (%"PRIu64" > %"PRIu8")", pos, parameter_offset);
        return PROTO_PARSE_ERR;
    }
    uint8_t padding = parameter_offset - pos;
    cursor_drop(cursor, padding);
    return PROTO_OK;
}

/*
 * Trans2 request
 * Word count > 0x0e
 *
 * Parameters
 * | USHORT              | USHORT         | USHORT            | USHORT       | UCHAR         | UCHAR     | USHORT | ULONG   | USHORT    |
 * | TotalParameterCount | TotalDataCount | MaxParameterCount | MaxDataCount | MaxSetupCount | Reserved1 | Flags  | Timeout | Reserved2 |
 *
 * | USHORT         | USHORT          | USHORT    | USHORT     | UCHAR      | UCHAR    | USHORT            |
 * | ParameterCount | ParameterOffset | DataCount | DataOffset | SetupCount | Reserved | Setup[SetupCount] |
 *
 * Data
 * | SMB_STRING | UCHAR  | UCHAR                             | UCHAR  | UCHAR                  |
 * | Name       | Pad1[] | Trans2_Parameters[ParameterCount] | Pad2[] | Trans2_Data[DataCount] |
 */
static enum proto_parse_status parse_trans2_request(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse trans2 request");
    cifs_parser->level_of_interest = 0;
    cifs_parser->subcommand.trans2_subcmd = 0;
    uint8_t const *start_cursor = cursor->head;
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x0e);
    if (word_count == -1) return PROTO_PARSE_ERR;

    cursor_drop(cursor, 2 + 2 // Total counts
            + 2 + 2 + 1       // Max counts
            + 1               // Reserved
            + 2 + 4 + 2);     // flags + timeout + reserved
    uint16_t parameter_count = cursor_read_u16le(cursor);
    uint16_t parameter_offset = cursor_read_u16le(cursor);
    uint16_t data_count = cursor_read_u16le(cursor);
    cursor_drop(cursor, 2 + 1 + 1); // data offset + setup count + reserved

    // TODO handle multiple setup count
    cifs_parser->subcommand.trans2_subcmd = info->subcommand.trans2_subcmd = cursor_read_u16le(cursor);
    info->set_values |= CIFS_TRANS2_SUBCMD;

    if (parse_and_check_byte_count_superior_or_equal(cursor, 0) == -1) return PROTO_PARSE_ERR;
    enum proto_parse_status status = PROTO_OK;
    if (PROTO_OK != (status = drop_parameter_padding(cursor, SMB_HEADER_SIZE, start_cursor, parameter_offset)))
        return status;

    switch (info->subcommand.trans2_subcmd) {
        /*
         * Trans2_Parameters
         * | USHORT | USHORT     | USHORT    | SMB_FILE_ATTRIBUTES (2 bytes) |
         * | Flags  | AccessMode | Reserved1 | FileAttributes                |
         *
         * | UTIME (4 bytes) | USHORT   | ULONG          | USHORT      | SMB_STRING |
         * | CreationTime    | OpenMode | AllocationSize | Reserved[5] | FileName   |
         *
         * Trans2_Data
         * | SMB_FEA_LIST          |
         * | ExtendedAttributeList |
         */
        case SMB_TRANS2_OPEN2:
            {
                // skip Flags, AccessMode, Reserved1, FileAttributes, CreationTime
                //      OpenMode, AllocationSize, Reserved[5], FileName
                CHECK_AND_DROP_WITH_PADDING(2 + 2 + 2 + 2 + 4 + 2 + 4 + 10);
                PARSE_SMB_PATH(info);
                info->meta_write_bytes = parameter_count + data_count;
            }
            break;
        case SMB_TRANS2_CREATE_DIRECTORY:
            /*
             * Trans2_Parameters
             * | ULONG    | SMB_STRING   |
             * | Reserved | DirectoryName|
             *
             * Trans2_Data
             * | SMB_FEA_LIST          |
             * | ExtendedAttributeList |
             */
            {
                CHECK_AND_DROP_WITH_PADDING(4);
                PARSE_SMB_PATH(info);
                info->meta_write_bytes = data_count;
            }
            break;
        case SMB_TRANS2_QUERY_FILE_INFORMATION:
            {
                CHECK(4);
                cifs_set_fid(info, cursor_read_u16le(cursor));
                info->level_of_interest = cifs_parser->level_of_interest = cursor_read_u16le(cursor);
                info->set_values |= CIFS_LEVEL_OF_INTEREST;
            }
            break;
        case SMB_TRANS2_QUERY_PATH_INFORMATION:
            {
                CHECK_AND_DROP_WITH_PADDING(2 + 4);
                PARSE_SMB_PATH(info);
            }
            break;
        case SMB_TRANS2_FIND_FIRST2:
            {
                CHECK_AND_DROP_WITH_PADDING(2 + 2 + 2 + 2 + 4);
                PARSE_SMB_PATH(info);
            }
            break;
        case SMB_TRANS2_SET_PATH_INFORMATION:
            {
                CHECK(8);
                info->level_of_interest = cifs_parser->level_of_interest = cursor_read_u16le(cursor);
                info->set_values |= CIFS_LEVEL_OF_INTEREST;
                cursor_drop(cursor, 4); // Reserved
                PARSE_SMB_PATH(info);

                switch(cifs_parser->level_of_interest) {
                    case SMB_POSIX_PATH_OPEN:
                        {
                            cursor_drop(cursor, 4); // drop flag fields
                            uint32_t posix_flags =cursor_read_u32le(cursor);
                            #define SMB_O_CREAT 0x10
                            #define SMB_O_DIRECTORY 0x200
                            if(SMB_O_CREAT == (posix_flags & SMB_O_CREAT))
                                info->parameters.flag_file |= CIFS_FILE_CREATE;
                            if(SMB_O_DIRECTORY == (posix_flags & SMB_O_DIRECTORY))
                                info->parameters.flag_file |= CIFS_FILE_DIRECTORY;
                        }
                        break;
                    case SMB_POSIX_PATH_UNLINK:
                        info->parameters.flag_file |= CIFS_FILE_UNLINK;
                        break;
                    default:
                        break;
                }

                info->meta_write_bytes = data_count;
            }
            break;
        case SMB_TRANS2_SET_FILE_INFORMATION:
            {
                CHECK(14);
                cifs_set_fid(info, cursor_read_u16le(cursor));

                info->meta_write_bytes = data_count;
            }
            break;
        case SMB_TRANS2_GET_DFS_REFERRAL:
            {
                CHECK_AND_DROP_WITH_PADDING(2);
                PARSE_SMB_PATH(info);
            }
            break;
        case SMB_TRANS2_FIND_NEXT2:
            {
                CHECK_AND_DROP_WITH_PADDING(2 + 2 + 2 + 2 + 4);
                PARSE_SMB_PATH(info);
            }
            break;
        case SMB_TRANS2_QUERY_FS_INFO:
            {
                /* It only contains an Information level */
            }
            break;
        default:
            break;
    }

    return PROTO_OK;
}

/*
 * Trans2 response
 * Word count = 0x0a or 0x00
 *
 * Parameters
 *
 * | USHORT              | USHORT         | USHORT    | USHORT         | USHORT          |
 * | TotalParameterCount | TotalDataCount | Reserved1 | ParameterCount | ParameterOffset |
 *
 * | USHORT                | USHORT    | USHORT     | USHORT           | UCHAR      |
 * | ParameterDisplacement | DataCount | DataOffset | DataDisplacement | SetupCount |
 *
 * | UCHAR     | USHORT            |
 * | Reserved2 | Setup[SetupCount] |
 *
 * Data
 *
 * | UCHAR  | UCHAR                             | UCHAR  | UCHAR                  |
 * | Pad1[] | Trans2_Parameters[ParameterCount] | Pad2[] | Trans2_Data[DataCount] |
 *
 * When a trans2 request is splitted on multiple smb request, the first response contains nothing
 * (WC and BC is 0) and tran2 secondary request should be send from client following this response.
 */
static enum proto_parse_status parse_trans2_response(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse trans2 response with previous subcmd %s, level of interest %s",
            smb_trans2_subcmd_2_str(cifs_parser->subcommand.trans2_subcmd),
            smb_file_info_levels_2_str(cifs_parser->level_of_interest));
    uint8_t const *start_cursor = cursor->head;
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x00);
    if (word_count == 0) return PROTO_OK; // Nothing to parse in this case
    else if (word_count != 0x0a) return PROTO_PARSE_ERR;

    cursor_drop(cursor, 2 + 2 + 2); // total counts + Reserved bytes

    uint16_t parameter_count = cursor_read_u16le(cursor);
    uint16_t parameter_offset = cursor_read_u16le(cursor);
    cursor_drop(cursor, 2); // parameter displacement
    uint16_t data_count = cursor_read_u16le(cursor);
    uint16_t data_offset = cursor_read_u16le(cursor);
    cursor_drop(cursor, 2 + 1 + 1); // data displacement + setup count + Reserved byte

    if (parse_and_check_byte_count_superior_or_equal(cursor, 0) == -1) return PROTO_PARSE_ERR;

    enum proto_parse_status status = PROTO_OK;
    if (PROTO_OK != (status = drop_parameter_padding(cursor, SMB_HEADER_SIZE, start_cursor, parameter_offset)))
        return status;

    uint8_t data_padding = data_offset - parameter_offset;
    SLOG(LOG_DEBUG, "Parse trans2 specific subcmd %s with data padding %"PRIu8, smb_trans2_subcmd_2_str(cifs_parser->subcommand.trans2_subcmd), data_padding);
    switch (cifs_parser->subcommand.trans2_subcmd) {
        /*
         * Trans2_Parameters
         * | USHORT | SMB_FILE_ATTRIBUTES (2 bytes) | UTIME        | ULONG        |
         * | FID    | FileAttributes                | CreationTime | FileDataSize |
         *
         * | USHORT     | USHORT       | SMB_NMPIPE_STATUS (2 bytes) | USHORT      |
         * | AccessMode | ResourceType | NMPipeStatus                | ActionTaken |
         *
         * | ULONG    | USHORT                       | ULONG                   |
         * | Reserved | ExtendedAttributeErrorOffset | ExtendedAttributeLength |
         *
         * No Trans2_Data
         */
        case SMB_TRANS2_OPEN2:
            {
                CHECK(2);
                cifs_set_fid(info, cursor_read_u16le(cursor));
                info->meta_read_bytes = parameter_count;
            }
            break;
        case SMB_TRANS2_CREATE_DIRECTORY:
            /* nothing to retrieve */
            break;

        /*
         * Level of interest SMB_POSIX_PATH_OPEN
         * | USHORT | USHORD | ULONG        | USHORD                  | USHORT  | Sizeof reply information |
         * | Flags  | FID    | CreateAction | Reply information level | Padding | Reply information        |
         */
        case SMB_TRANS2_SET_PATH_INFORMATION:
            {
                // Parameters
                CHECK(data_padding);
                cursor_drop(cursor, data_padding);
                switch (cifs_parser->level_of_interest) {
                    case SMB_POSIX_PATH_OPEN:
                        {
                            CHECK(4);
                            // Data
                            cursor_drop(cursor, 2); // Flags
                            cifs_set_fid(info, cursor_read_u16le(cursor));
                        }
                        break;
                    default:
                        break;
                }
            }
            break;
        case SMB_TRANS2_QUERY_PATH_INFORMATION:
        case SMB_TRANS2_QUERY_FILE_INFORMATION:
            {
                // ea error offset
                CHECK(2);
                uint16_t ea_err_offset = cursor_read_u16le(cursor);
                if(0x00 == ea_err_offset)
                    info->meta_read_bytes = data_count;
            }
        case SMB_TRANS2_SET_FILE_INFORMATION:
            {
                CHECK(data_padding);
                // TODO Check error...
            }
            break;
        case SMB_TRANS2_QUERY_FS_INFO:
            {
                info->meta_read_bytes = data_count;
            }
            break;
        case SMB_TRANS2_FIND_NEXT2:
        case SMB_TRANS2_FIND_FIRST2:
            info->meta_read_bytes = data_count;
            break;
        case SMB_TRANS2_GET_DFS_REFERRAL:
            /* nothing to retrieve */
            break;
        default:
            break;
    }
    return status;
}

/*
 * Trans2 secondary request
 * Word count = 0x09
 *
 * Parameters
 *
 * | USHORT              | USHORT         | USHORT         | USHORT          |
 * | TotalParameterCount | TotalDataCount | ParameterCount | ParameterOffset |
 *
 * | USHORT                | USHORT    | USHORT     | USHORT           | USHORT     |
 * | ParameterDisplacement | DataCount | DataOffset | DataDisplacement | FID        |
 *
 * Data
 *
 * | UCHAR  | UCHAR                             | UCHAR  | UCHAR                  |
 * | Pad1[] | Trans2_Parameters[ParameterCount] | Pad2[] | Trans2_Data[DataCount] |
 */
static enum proto_parse_status parse_trans2_secondary_request(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if (-1 == parse_and_check_word_count(cursor, 0x09)) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 2 + 2 + 2 + 2 + 2); // Reach data count
    uint16_t data_count = cursor_read_u16le(cursor);
    cursor_drop(cursor, 2 + 2); // reach fid
    cifs_set_fid(info, cursor_read_u16le(cursor));
    switch (cifs_parser->subcommand.trans2_subcmd) {
        case SMB_TRANS2_OPEN2:
        case SMB_TRANS2_FIND_FIRST2:
        case SMB_TRANS2_FIND_NEXT2:
        case SMB_TRANS2_QUERY_FS_INFO:
        case SMB_TRANS2_QUERY_FILE_INFORMATION:
        case SMB_TRANS2_QUERY_PATH_INFORMATION:
            info->meta_read_bytes = data_count;
            break;
        case SMB_TRANS2_SET_FS_INFORMATION:
        case SMB_TRANS2_SET_PATH_INFORMATION:
        case SMB_TRANS2_SET_FILE_INFORMATION:
            info->meta_write_bytes = data_count;
            break;
        default:
            break;
    }
    return PROTO_OK;
}

/*
 * Write andx query
 * Word count 0x0c or 0x0e
 *
 * Parameters
 * | 4 bytes | USHORT | ULONG  | ULONG   |
 * | AndX    | FID    | Offset | Timeout |
 *
 * | USHORT    | USHORT    | USHORT   | USHORT     | USHORT     | ULONG                 |
 * | WriteMode | Remaining | Reserved | DataLength | DataOffset | OffsetHigh (optional) |
 *
 * Data
 * | UCHAR | UCHAR            |
 * | Pad   | Data[DataLength] |
 */
static enum proto_parse_status parse_write_andx_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count_superior_or_equal(cursor, 0x0c) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 4); // skip AndX
    cifs_set_fid(info, cursor_read_u16le(cursor));
    cursor_drop(cursor, 4+4+2+2+2); // skip offset, timeout, writemode, remaining, reserved
    info->query_write_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Write andx response
 * Word count 0x06
 *
 * Parameters
 * | 4 bytes | USHORT | USHORT    | ULONG    |
 * | AndX    | Count  | Available | Reserved |
 *
 * No Data
 */
static enum proto_parse_status parse_write_andx_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x06) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 4); // skip AndX
    info->response_write_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Close request
 * Word count 0x03
 *
 * Parameters
 * | USHORT | UTIME            |
 * | Count  | LastTimeModified |
 *
 * No Data
 */
static enum proto_parse_status parse_close_request(struct cifs_parser unused_ *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x03) == -1) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Delete directory request
 * Word count 0x00
 *
 * No Parameters
 *
 * Data
 * | UCHAR 0x04   | SMB_STRING    |
 * | BufferFormat | DirectoryName |
 */
static enum proto_parse_status parse_delete_directory_request(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x00) == -1)
        return PROTO_PARSE_ERR;
    int byte_count = parse_and_check_byte_count_superior_or_equal(cursor, 0x01);
    if (byte_count == -1) return PROTO_PARSE_ERR;
    uint8_t buffer_format = cursor_read_u8(cursor);
    if (buffer_format != 0x04) {
        SLOG(LOG_DEBUG, "Buffer format must have value 0x04, got %"PRIu8, buffer_format);
        return PROTO_PARSE_ERR;
    }
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Delete request
 * Word count 0x01
 *
 * Parameters
 * | USHORT            |
 * | Search attributes |
 *
 * Data
 * | UCHAR 0x04   | SMB_STRING |
 * | BufferFormat | FileName   |
 */
static enum proto_parse_status parse_delete_request(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x01) == -1)
        return PROTO_PARSE_ERR;
    cursor_drop(cursor, 2); // Search attributes
    int byte_count = parse_and_check_byte_count_superior_or_equal(cursor, 0x01);
    if (byte_count == -1) return PROTO_PARSE_ERR;
    uint8_t buffer_format = cursor_read_u8(cursor);
    if (buffer_format != 0x04) {
        SLOG(LOG_DEBUG, "Buffer format must have value 0x04, got %"PRIu8, buffer_format);
        return PROTO_PARSE_ERR;
    }
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Read AndX request
 * Word count 0x0a or 0x0c
 *
 * Parameters
 * | 4 bytes | USHORT | ULONG  | ULONG   |
 * | AndX    | FID    | Offset | Timeout |
 *
 * | USHORT                  | USHORT                  | ULONG   | USHORT    | ULONG                 |
 * | MaxCountOfBytesToReturn | MinCountOfBytesToReturn | Timeout | Remaining | OffsetHigh (optional) |
 *
 * No Data
 */
static enum proto_parse_status parse_read_andx_request(struct cifs_parser unused_ *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count_superior_or_equal(cursor, 0x0a) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 4); // skip AndX
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Read AndX response
 * Word count 0x0c
 *
 * Parameters
 * | 4 bytes | USHORT    | USHORT             | USHORT    | USHORT     | USHORT     | USHORT * 5   |
 * | AndX    | Available | DataCompactionMode | Reserved1 | DataLength | DataOffset | Reserved2[5] |
 *
 * Data
 * | UCHAR | UCHAR |
 * | Pad[] | Data  |
 */
static enum proto_parse_status parse_read_andx_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x0c) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 4+2+2+2); // skip AndX, Available, DataCompressionMode, Reserved
    info->response_read_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * NT Create AndX request
 * Word count 0x18
 *
 * Parameters
 *
 *
 * | 4 bytes      | UCHAR     |  USHORT      | ULONG | ULONG            | ULONG
 * | AndX         | Reserved  |  NameLength  | Flags | RootDirectoryFID | DesiredAccess
 *
 * | LARGE_INTEGER    | SMB_EXT_FILE_ATTR | ULONG       | ULONG
 * | AllocationSize   | ExtFileAttributes | ShareAccess | CreateDisposition
 *
 * | ULONG         | ULONG              | UCHAR
 * | CreateOptions | ImpersonationLevel | SecurityFlags
 *
 * Data
 * | USHORT    | SMB_STRING |
 * | ByteCount | Filename   |
 */
static enum proto_parse_status parse_nt_create_andx_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x18) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 0x18*2);

    info->meta_write_bytes = 0x18*2 + cursor_read_u16le(cursor);

    cursor_drop(cursor, compute_padding(cifs_parser, cursor, 0, 2)); // skip padding
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * NT Create AndX response
 * Word count 0x22
 *
 * Parameters
 * | 4 bytes | UCHAR       | USHORT | ULONG             | FILETIME   | FILETIME
 * | AndX    | OpLockLevel | FID    | CreateDisposition | CreateTime | LastAccessTime
 *
 * | FILETIME     | FILETIME       | SMB_EXT_FILE_ATTR | LARGE_INTEGER  | LARGE_INTEGER
 * | LastWriteTime| LastChangeTime | ExtFileAttributes | AllocationSize | EndOfFile
 *
 * | USHORT       | SMB_NMPIPE_STATUS |
 * | ResourceType | NMPipeStatus      |
 * No Data
 */
static enum proto_parse_status parse_nt_create_andx_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    // there seems to be a problem with the specs that specify 0x22 when we may have 0x2a
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x22);
    if(-1 == word_count) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 4 + 1); // skip AndX and OpLockLevel
    cifs_set_fid(info, cursor_read_u16le(cursor));
    info->meta_read_bytes = word_count * 2;
    return PROTO_OK;
}

/*
 * Flush request
 * Word count 0x01
 *
 * Parameters
 * | USHORT |
 * | FID    |
 *
 * No Data
 */
static enum proto_parse_status parse_flush_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x01) == -1) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Rename request
 * Word count 0x01
 *
 * Parameters
 * | USHORT           |
 * | SearchAttributes |
 *
 * Data
 * | USHORT    | UCHAR         | SMB_STRING  | UCHAR         | SMB_STRING  |
 * | ByteCount | BufferFormat1 | OldFileName | BufferFormat2 | NewFileName |
 */
static enum proto_parse_status parse_rename_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x01) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 2); // skip SearchAttributes

    if(parse_and_check_byte_count_superior_or_equal(cursor, 0x0002) == -1) return PROTO_PARSE_ERR;

    uint8_t padding = compute_padding(cifs_parser, cursor, 1, 2);
    cursor_drop(cursor, 1 + padding); // skip BufferFormat1

    PARSE_SMB_PATH(info);

    return PROTO_OK;
}

/*
 * Locking AndX request
 * Word count 0x08
 *
 * Parameters
 * | 4 bytes | USHORT | UCHAR      | UCHAR          | ULONG
 * | AndX    | FID    | TypeOfLock | NewOpLockLevel | Timeout
 *
 * | USHORT                   | USHORT                 |
 * | NumberOfRequestedUnlocks | NumberOfRequestedLocks |
 *
 * Data
 * | LOCKING_ANDX_RANGE                | LOCKING_ANDX_RANGE            |
 * | Unlocks[NumberOfRequestedUnlocks] | Locks[NumberOfRequestedLocks] |
 */
static enum proto_parse_status parse_locking_andx_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(parse_and_check_word_count(cursor, 0x08) == -1) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 4); // skip AndX
    cifs_set_fid(info, cursor_read_u16le(cursor));
    info->parameters.lock_type = cursor_read_u8(cursor);
    return PROTO_OK;
}

/*
 * Open AndX request
 * Word count 0x0f
 *
 * Parameters
 * | 4 bytes | USHORT | USHORT     | 2 bytes     | 2 bytes   | UTIME (4 bytes)
 * | AndX    | Flags  | AccessMode | SearchAttrs | FileAttrs | CreationTime
 *
 * | USHORT   | ULONG          | ULONG   | USHORT[2]   |
 * | OpenMode | AllocationSize | Timeout | Reserved[2] |
 *
 * Data
 * | SMB_STRING |
 * | FileName   |
 */
static enum proto_parse_status parse_open_andx_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    int word_count = parse_and_check_word_count(cursor, 0x0f);
    if(-1 == word_count) return PROTO_PARSE_ERR;
    cursor_drop(cursor, word_count*2); // skip parameters

    int byte_count = parse_and_check_byte_count_superior_or_equal(cursor, 0x2);
    if(-1 == byte_count) return PROTO_PARSE_ERR;
    info->meta_write_bytes = word_count*2 + byte_count;

    cursor_drop(cursor, compute_padding(cifs_parser, cursor, 0, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Open AndX response
 * Word count 0x0f or 0x13
 *
 * Parameters
 * | 4 bytes | USHORT | SMB_FILE_ATTRIBUTES | UTIME         | ULONG        | USHORT       |
 * | AndX    | FID    | FileAttrs           | LastWriteTime | FileDataSize | AccessRights |
 *
 * | USHORT       | SMB_NMPIPE_STATUS | USHORT      |
 * | ResourceType | NBPipeStatus      | OpenResults |
 *
 * 0x0f version:
 * |  USHORT[3] |
 * |  Reserved  |
 *
 * 0x13 version:
 * | ULONG     | USHORT   | ACCESS_MASK         | ACCESS_MASK              |
 * | ServerFID | Reserved | MaximalAccessRights | GuestMaximalAccessRights |
 *
 * No Data
 */
static enum proto_parse_status parse_open_andx_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x0f);
    if(word_count != 0x0f && word_count != 0x13) return PROTO_PARSE_ERR;
    info->meta_read_bytes = word_count * 2;
    cursor_drop(cursor, 4); // skip AndX
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * NT Transact request
 * Word count 0x13
 *
 * Parameters
 * | UCHAR         | USHORT    | ULONG               | ULONG          |
 * | MaxSetupCount | Reserved1 | TotalParameterCount | TotalDataCount |
 *
 * | ULONG             | ULONG        | ULONG          | ULONG           |
 * | MaxParameterCount | MaxDataCount | ParameterCount | ParameterOffset |
 *
 * | ULONG     | ULONG      | UCHAR      | USHORT   | USHORT[]          |
 * | DataCount | DataOffset | SetupCount | Function | Setup[SetupCount] |
 *
 * Data
 * | UCHAR  | UCHAR[]                             | UCHAR  | UCHAR[]                  |
 * | Pad1[] | NT_Trans_Parameters[ParameterCount] | Pad2[] | NT_Trans_Data[DataCount] |
 */
static enum proto_parse_status parse_nt_transact_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse NT Transact request");
    cifs_parser->subcommand.nt_trans_subcmd = 0;
    uint8_t const *start_cursor = cursor->head;
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x13);
    if (word_count == -1) return PROTO_PARSE_ERR;

    // skip MaxSetupCount, Reserved1, TotalParamCount, TotalDataCount, MaxParamCount, MaxDataCount, ParamCount
    cursor_drop(cursor, 1 + 2 + 4 + 4 + 4 + 4 + 4);
    uint16_t parameter_offset = cursor_read_u32le(cursor);
    uint16_t data_count = cursor_read_u32le(cursor);
    cursor_drop(cursor, 4 + 1); // skip DataOffset, setupcount

    cifs_parser->subcommand.nt_trans_subcmd = info->subcommand.nt_transact_subcmd = cursor_read_u16le(cursor);
    info->set_values |= CIFS_NT_TRANSACT_SUBCMD;

    enum proto_parse_status status = PROTO_OK;
    switch(info->subcommand.nt_transact_subcmd) {
        case SMB_NT_TRANSACT_IOCTL:
            /*
             * Setup (8 bytes)
             * | ULONG        | USHORT | BOOLEAN | BOOLEAN |
             * | FunctionCode | FID    | IsFsctl | IsFlags |
             */
        case SMB_NT_TRANSACT_NOTIFY_CHANGE:
            /*
             * Setup (8 bytes)
             * | ULONG            | USHORT | BOOLEAN   | UCHAR    |
             * | CompletionFilter | FID    | WatchTree | Reserved |
             */
            CHECK(4 + 2);
            cursor_drop(cursor, 4); // skip until the FID
            cifs_set_fid(info, cursor_read_u16le(cursor));
            break;
        case SMB_NT_TRANSACT_CREATE:
            /*
             * NT_Trans_Parameters
             * | ULONG | ULONG            | ULONG         | LARGE_INTEGER (8 bytes) |
             * | Flags | RootDirectoryFID | DesiredAccess | AllocationSize          |
             *
             * | SMB_EXT_FILE_ATTR | ULONG       | ULONG             | ULONG         |
             * | ExtFileAttributes | ShareAccess | CreateDisposition | CreateOptions |
             *
             * | ULONG                    | ULONG    | ULONG      | ULONG              |
             * | SecurityDescriptorLength | EALength | NameLength | ImpersonationLevel |
             *
             * | UCHAR         | UCHAR[]          |
             * | SecurityFlags | Name[NameLength] |
             *
             * NT_Trans_Data
             * | SECURITY_DESCRIPTOR (variable) | FILE_FULL_EA_INFORMATION (variable) |
             * | SecurityDescriptor             | ExtendedAttributes[]                |
             */
            {
                // skip to the NT_Trans_Parameters
                if (PROTO_OK != (status = drop_parameter_padding(cursor, SMB_HEADER_SIZE, start_cursor, parameter_offset)))
                    return status;

                // skip until the SecurityDescriptorLength
                CHECK_AND_DROP(4 + 4 + 4 + 8 + 4 + 4 + 4 + 4);
                uint32_t security_desc_length = cursor_read_u32le(cursor);
                uint32_t ea_info_length = cursor_read_u32le(cursor);
                info->meta_write_bytes = security_desc_length + ea_info_length;
                // skip until the Name
                CHECK_AND_DROP_WITH_PADDING(4 + 4 + 1);

                PARSE_SMB_PATH(info);
            }
            break;
        case SMB_NT_TRANSACT_QUERY_SECURITY_DESC:
            /*
             * NT_Trans_Parmeters[ParameterCount]
             * | USHORT | USHORT   | ULONG              |
             * | FID    | Reserved | SecurityInfoFields |
             */
            {
                // skip to the NT_Trans_Parameters
                if (PROTO_OK != (status = drop_parameter_padding(cursor, SMB_HEADER_SIZE, start_cursor, parameter_offset)))
                    return status;
                CHECK(2);
                cifs_set_fid(info, cursor_read_u16le(cursor));
            }
            break;
        case SMB_NT_TRANSACT_SET_SECURITY_DESC:
            /*
             * NT_Trans_Parameters (8 bytes)
             * | USHORT | USHORT   | ULONG               |
             * | FID    | Reserved | SecurityInformation |
             *
             * NT_Trans_Data (variable)
             * | SECURITY_DESCRIPTOR (variable) |
             * | SecurityDescriptor             |
             */
            {
                // skip to the NT_Trans_Parameters
                if (PROTO_OK != (status = drop_parameter_padding(cursor, SMB_HEADER_SIZE, start_cursor, parameter_offset)))
                    return status;
                CHECK(2);
                cifs_set_fid(info, cursor_read_u16le(cursor));
                info->meta_write_bytes = data_count;
            }
            break;
        case SMB_NT_TRANSACT_RENAME:
            /* Reserved but not implemented */
            break;
        default:
            break;
    }

    return PROTO_OK;
}

/*
 * NT Transact response
 * Word >= count 0x12
 *
 * Parameters
 * | UCHAR[3]  | ULONG               | ULONG          |
 * | Reserved1 | TotalParameterCount | TotalDataCount |
 *
 * | ULONG          | ULONG           | ULONG                 |
 * | ParameterCount | ParameterOffset | ParameterDisplacement |
 *
 * | ULONG     | ULONG      | ULONG            | UCHAR      | USHORT[]          |
 * | DataCount | DataOffset | DataDisplacement | SetupCount | Setup[SetupCount] |
 *
 * Data
 * | UCHAR  | UCHAR[]                             | UCHAR  | UCHAR[]                  |
 * | Pad1[] | NT_Trans_Parameters[ParameterCount] | Pad2[] | NT_Trans_Data[DataCount] |
 */
static enum proto_parse_status parse_nt_transact_response(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse NT Transact response with previous subcmd %s, level of interest %s",
            smb_nt_trans_subcmd_2_str(cifs_parser->subcommand.nt_trans_subcmd),
            smb_file_info_levels_2_str(cifs_parser->level_of_interest));
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x12);
    if (word_count == -1) return PROTO_PARSE_ERR;

    cursor_drop(cursor, 3 + 4 + 4); // skip Reserved1, TotalParamCount, TotalDataCount
    uint32_t parameter_count = cursor_read_u32le(cursor);
    uint32_t parameter_offset = cursor_read_u32le(cursor);
    cursor_drop(cursor, 4); // ParameterDisplacement
    uint32_t data_count = cursor_read_u32le(cursor);
    cursor_drop(cursor, 4 + 4 + 1); // skip DataOffset, DataDisplacement, setupcount

    // Compute padding
    uint8_t start_parameter = SMB_HEADER_SIZE + word_count * 2 + 2 + 1;
    if(start_parameter > parameter_offset) {
        SLOG(LOG_DEBUG, "Start_parameter is greated than parameter offset (%"PRIu8" > %"PRIu8")", start_parameter, parameter_offset);
        return PROTO_PARSE_ERR;
    }
    uint8_t padding = parameter_offset - start_parameter;
    SLOG(LOG_DEBUG, "Found start parameter %u, offset %u, padding %u", start_parameter, parameter_offset, padding);
    // skip the SMB parameters
    if (-1 == parse_and_check_byte_count_superior_or_equal(cursor, padding))
        return PROTO_PARSE_ERR;
    cursor_drop(cursor, padding);

    SLOG(LOG_DEBUG, "Parse NT Transact specific subcmd %s",
            smb_nt_trans_subcmd_2_str(cifs_parser->subcommand.nt_trans_subcmd));
    switch(cifs_parser->subcommand.nt_trans_subcmd) {
        case SMB_NT_TRANSACT_CREATE:
            /*
             * NT_Trans_Parameters
             * | UCHAR       | UCHAR    | USHORT | ULONG        | ULONG         |
             * | OpLockLevel | Reserved | FID    | CreateAction | EAErrorOffset |
             *
             * | FILETIME     | FILETIME       | FILETIME      | FILETIME       |
             * | CreationTime | LastAccessTime | LastWriteTime | LastChangeTime |
             *
             * | SMB_EXT_FILE_ATTR | LARGE_INTEGER  | LARGE_INTEGER |
             * | ExtFileAttributes | AllocationSize | EndOfFile     |
             *
             * | USHORT       | SMB_NMPIPE_STATUS | UCHAR     |
             * | ResourceType | NMPipeStatus      | Directory |
             */
            cursor_drop(cursor, 1+1); // skip OpLockLevel, Reserved
            cifs_set_fid(info, cursor_read_u16le(cursor));
            cursor_drop(cursor, 8); // skip CreateAction
            uint32_t ea_err_offset = cursor_read_u32le(cursor);
            if(0x00 == ea_err_offset)
                info->meta_read_bytes = parameter_count;
            break;
        case SMB_NT_TRANSACT_IOCTL:
            /*
             * NT_Trans_Data
             * | UCHAR (variable)     |
             * | Data[DataCount] |
             */
            info->response_read_bytes = data_count;
            break;
        case SMB_NT_TRANSACT_SET_SECURITY_DESC:
            /* nothing to retrieve */
            break;
        case SMB_NT_TRANSACT_NOTIFY_CHANGE:
            /* nothing to retrieve */
            /*
             * NT_Trans_Parameters
             * | FILE_NOTIFY_INFORMATION |
             * | FileNotifyInformation[] |
             */
            info->meta_read_bytes = parameter_count;
            break;
        case SMB_NT_TRANSACT_RENAME:
            /* Reserved but not implemented */
            break;
        case SMB_NT_TRANSACT_QUERY_SECURITY_DESC:
            /*
             * NT_Trans_Parameters
             * | ULONG        |
             * | LengthNeeded |
             *
             * NT_Trans_Data
             * | SECURITY_DESCRIPTOR  |
             * | SecurityDescriptor[] |
             */
            CHECK(4);
            info->meta_read_bytes = cursor_read_u32le(cursor);
            break;
        default:
            break;
    }
    return PROTO_OK;
}

/*
 * Transaction request
 * Word count > 0x0e
 *
 * Parameters
 * | USHORT              | USHORT         | USHORT            | USHORT       |
 * | TotalParameterCount | TotalDataCount | MaxParameterCount | MaxDataCount |
 *
 * | UCHAR         | UCHAR     | USHORT | ULONG   | USHORT    | USHORT         |
 * | MaxSetupCount | Reserved1 | Flags  | Timeout | Reserved2 | ParameterCount |
 *
 * | USHORT          | USHORT    | USHORT     | UCHAR      | UCHAR     | USHORT[]          |
 * | ParameterOffset | DataCount | DataOffset | SetupCount | Reserved3 | Setup[SetupCount] |
 *
 * Data
 * | SMB_STRING | UCHAR  | UCHAR                             | UCHAR  | UCHAR                  |
 * | Name       | Pad1[] | Trans_Parameters[ParameterCount] | Pad2[] | Trans_Data[DataCount] |
 */
static enum proto_parse_status parse_transaction_request(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse transaction request");
    cifs_parser->level_of_interest = 0;
    cifs_parser->subcommand.transaction_subcmd = 0;
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x0e);
    if (word_count == -1) return PROTO_PARSE_ERR;

    // skip until the ParameterCount
    cursor_drop(cursor, 2 + 2 + 2 + 2 + 1 + 1 + 2 + 4 + 2);
    uint16_t parameter_count = cursor_read_u16le(cursor);
    // drop the ParameterOffset
    cursor_drop(cursor, 2);
    uint16_t data_count = cursor_read_u16le(cursor);
    // drop the DataOffset
    cursor_drop(cursor, 2);
    uint8_t setup_count = cursor_read_u8(cursor);
    if (setup_count == 0) return PROTO_OK;
    cursor_drop(cursor, 1); // reserved3

    // read subcommand
    cifs_parser->subcommand.transaction_subcmd = info->subcommand.transaction_subcmd = cursor_read_u16le(cursor);
    info->set_values |= CIFS_TRANSACTION_SUBCMD;
    switch (info->subcommand.transaction_subcmd) {
        case SMB_TRANS_SET_NMPIPE_STATE:
            /*
             * Setup
             * | USHORT     | USHORT |
             * | Subcommand | FID    |
             *
             * Data:
             * | USHORT    | SMB_STRING | ...
             * | ByteCount | Name       | ...
             * The Name always contains "/PIPE/" for these commands.
             *
             * Trans_Parameters
             * | USHORT    |
             * | PipeState |
             **/
            // retrieve fid
            cifs_set_fid(info, cursor_read_u16le(cursor));
            info->meta_write_bytes = parameter_count;
            break;

        case SMB_TRANS_RAW_READ_NMPIPE:
        case SMB_TRANS_QUERY_NMPIPE_STATE:
        case SMB_TRANS_QUERY_NMPIPE_INFO:
        case SMB_TRANS_PEEK_NMPIPE:
        case SMB_TRANS_READ_NMPIPE:
            /*
             * Setup
             * | USHORT     | USHORT | ...
             * | Subcommand | FID    | ...
             *
             * Data:
             * | USHORT    | SMB_STRING |
             * | ByteCount | Name       |
             * The Name always contains "/PIPE/" for these commands.
             **/
            // retrieve fid
            cifs_set_fid(info, cursor_read_u16le(cursor));
            break;

        case SMB_TRANS_TRANSACT_NMPIPE:
        case SMB_TRANS_RAW_WRITE_NMPIPE:
        case SMB_TRANS_WRITE_NMPIPE:
            /*
             * Setup
             * | USHORT     | USHORT |
             * | Subcommand | FID    |
             *
             * Data:
             * | USHORT    | SMB_STRING |
             * | ByteCount | Name       |
             * The Name always contains "/PIPE/" for these commands.
             *
             * Trans_Data
             * | UCHAR (variable |
             * | WriteData[]     |
             **/
            // retrieve fid
            cifs_set_fid(info, cursor_read_u16le(cursor));
            info->query_write_bytes = data_count;
            break;

        case SMB_TRANS_WAIT_NMPIPE:
        case SMB_TRANS_CALL_NMPIPE:
            /*
             * Data:
             * | USHORT    | SMB_STRING |
             * | ByteCount | Name       |
             * The name field MUST be set to the name of the pipe, in the format
             * \PIPE\<pipename>.
             */
            {
                CHECK_AND_DROP_WITH_PADDING(2 + 2); // drop the end of the setup, and drop bytecount
                PARSE_SMB_PATH(info);
            }
            break;
        default:
            break;
    }

    return PROTO_OK;
}

/*
 * Transaction request
 * Word count > 0x0a
 *
 * Parameters
 * | USHORT              | USHORT         |
 * | TotalParameterCount | TotalDataCount |
 *
 * | USHORT    | USHORT         | USHORT          | USHORT                |
 * | Reserved1 | ParameterCount | ParameterOffset | ParameterDisplacement |
 *
 * | USHORT    | USHORT     | USHORT           | UCHAR      | UCHAR     | USHORT[]          |
 * | DataCount | DataOffset | DataDisplacement | SetupCount | Reserved2 | Setup[SetupCount] |
 *
 * Data
 * | UCHAR  | UCHAR                             | UCHAR  | UCHAR                  |
 * | Pad1[] | Trans_Parameters[ParameterCount] | Pad2[] | Trans_Data[DataCount] |
 */
static enum proto_parse_status parse_transaction_response(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    SLOG(LOG_DEBUG, "Parse transaction response with previous subcmd %s, level of interest %s",
            smb_transaction_subcmd_2_str(cifs_parser->subcommand.transaction_subcmd),
            smb_file_info_levels_2_str(cifs_parser->level_of_interest));
    uint8_t const *start_cursor = cursor->head;
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x0a);
    if (word_count == -1) return PROTO_PARSE_ERR;

    cursor_drop(cursor, 2 + 2 + 2); // total count and data counts + Reserved1

    // read parameter count and offset
    uint16_t parameter_count = cursor_read_u16le(cursor);
    uint16_t parameter_offset = cursor_read_u16le(cursor);
    cursor_drop(cursor, 2); // skip param displacement
    // Read Data Count
    uint16_t data_count = cursor_read_u16le(cursor);

    enum proto_parse_status status = PROTO_OK;
    if (PROTO_OK != (status = drop_parameter_padding(cursor, SMB_HEADER_SIZE, start_cursor, parameter_offset)))
        return status;

    switch (cifs_parser->subcommand.transaction_subcmd) {
        case SMB_TRANS_SET_NMPIPE_STATE:
            /* nothing to retrieve */
            break;
        case SMB_TRANS_READ_NMPIPE:
        case SMB_TRANS_RAW_READ_NMPIPE:
            info->response_read_bytes = data_count;
            break;
        case SMB_TRANS_QUERY_NMPIPE_STATE:
            info->meta_read_bytes = parameter_count;
            break;
        case SMB_TRANS_QUERY_NMPIPE_INFO:
            /*
             * Trans_Parameters
             * | USHORT           | USHORT          | UCHAR            |
             * | OutputBufferSize | InputBufferSize | MaximumInstances |
             *
             * | UCHAR            | UCHAR          | SMB_STRING |
             * | CurrentInstances | PipeNameLength | PipeName   |
             */
            {
                // skip to the smb string
                CHECK_AND_DROP_WITH_PADDING(2 + 2 + 1 + 1 + 1);
                PARSE_SMB_PATH(info);
                info->meta_read_bytes = data_count;
            }
            break;
        case SMB_TRANS_PEEK_NMPIPE:
            info->response_read_bytes = data_count;
            break;
        case SMB_TRANS_TRANSACT_NMPIPE:
            info->response_read_bytes = data_count;
            break;
        case SMB_TRANS_WRITE_NMPIPE:
        case SMB_TRANS_RAW_WRITE_NMPIPE:
            /*
             * Trans_Parameters
             * | USHORT       |
             * | BytesWritten |
             */
            {
                CHECK(2);
                info->response_write_bytes = cursor_read_u16le(cursor);
            }
            break;
        case SMB_TRANS_WAIT_NMPIPE:
            /* nothing to retrieve */
            break;
        case SMB_TRANS_CALL_NMPIPE:
            /*
             * The TRANS_CALL_NMPIPE subcommand allows a client to open a named pipe,
             * issue a write to the named pipe, issue a read from the named pipe, and
             * close the named pipe.
             */
            info->response_write_bytes = info->response_read_bytes = data_count;
            break;
        default:
            break;
    }

    return PROTO_OK;
}

/*
 * Write request
 * Word count 0x05
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_WRITE_ANDX command.
 *
 * Parameters
 * | USHORT | USHORT              | ULONG              |
 * | FID    | CountOfBytesToWrite | WriteOffsetInBytes |
 *
 * | USHORT                              |
 * | EstimateOfRemainingBytesToBeWritten |
 *
 * Data
 * | UCHAR        | UCHAR      | UCHAR[]                     |
 * | BufferFormat | DataLength | Data[ CountOfBytesToWrite ] |
 */
static enum proto_parse_status parse_write_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    info->query_write_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Write response
 * Word count 0x01
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_WRITE_ANDX command.
 *
 * Parameters
 * | CountOfBytesWritten |
 * | USHORT              |
 *
 * No Data
 */
static enum proto_parse_status parse_write_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    info->response_write_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Read request
 * Word count 0x05
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_READ_ANDX command.
 *
 * Parameters
 * | USHORT | USHORT             | ULONG             |
 * | FID    | CountOfBytesToRead | ReadOffsetInBytes |
 *
 * | USHORT                           |
 * | EstimateOfRemainingBytesToBeRead |
 *
 * No Data
 */
static enum proto_parse_status parse_read_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Read response
 * Word count 0x05
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_WRITE_ANDX command.
 *
 * Parameters
 * | CountOfBytesReturned | Reserved[4] |
 * | USHORT               | USHORT      |
 *
 * Data
 * | BufferFormat | CountOfBytesRead | Bytes[ CountOfBytesRead ] |
 * | UCHAR        | USHORT           | UCHAR                     |
 */
static enum proto_parse_status parse_read_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    info->response_read_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Create directory request
 * Word count 0x00
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the TRANS2_CREATE_DIRECTORY subcommand.
 *
 * No Parameters
 *
 * Data
 * | UCHAR        | SMB_STRING    |
 * | BufferFormat | DirectoryName |
 */
static enum proto_parse_status parse_create_directory_request(struct cifs_parser* cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    // check word count and byte count
    if(-1 == parse_and_check_word_count(cursor, 0x00)) return PROTO_PARSE_ERR;
    if (-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x02))
        return PROTO_PARSE_ERR;

    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Query information disk response
 * Word count 0x05
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 command along
 * with a subcommand of TRANS2_QUERY_FS_INFORMATION.
 *
 * Parameters
 * | USHORT     | USHORT        | USHORT    | USHORT    | USHORT   |
 * | TotalUnits | BlocksPerUnit | BlockSize | FreeUnits | Reversed |
 *
 * No Data
 */
static enum proto_parse_status parse_query_info_disk_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    // check word count and byte count
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    info->meta_read_bytes = 0x05 * 2;
    return PROTO_OK;
}

/*
 * Create directory request
 * Word count 0x00
 *
 * No Parameters
 *
 * Data
 * | UCHAR        | SMB_STRING    |
 * | BufferFormat | DirectoryName |
 */
static enum proto_parse_status parse_check_directory_request(struct cifs_parser* cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    // check word count and byte count
    if(-1 == parse_and_check_word_count(cursor, 0x00)) return PROTO_PARSE_ERR;
    if (-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x02))
        return PROTO_PARSE_ERR;

    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Open request
 * Word count 0x02
 *
 * Parameters
 * | USHORT     | SMB_FILE_ATTRIBUTES (2 bytes) |
 * | AccessMode | SearchAttributes              |
 *
 * Data
 * | UCHAR        | SMB_STRING |
 * | BufferFormat | FileName   |
 */
static enum proto_parse_status parse_open_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x02)) return PROTO_PARSE_ERR;
    cursor_drop(cursor, 0x02*2); // skip parameters

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x2)) return PROTO_PARSE_ERR;

    // skip to smb string
    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Open response
 * Word count 0x07
 *
 * Parameters
 * | USHORT | SMB_FILE_ATTRIBUTES (2 bytes) | UTIME        | ULONG    | USHORT     |
 * | FID    | FileAttrs                     | LastModified | FileSize | AccessMode |
 *
 * No Data
 */
static enum proto_parse_status parse_open_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    int word_count = parse_and_check_word_count(cursor, 0x07);
    if(-1 == word_count) return PROTO_PARSE_ERR;
    info->meta_read_bytes = word_count * 2;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Query information request
 * Word count 0x00
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_WRITE_ANDX command.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2
 * subcommand TRANS2_QUERY_PATH_INFORMATION instead.
 *
 * No Parameters
 *
 * Data
 * | UCHAR        | SMB_STRING |
 * | BufferFormat | FileName   |
 */
static enum proto_parse_status parse_query_info_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x00)) return PROTO_PARSE_ERR;

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x2)) return PROTO_PARSE_ERR;

    // skip to smb string
    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Query information response
 * Word count 0x0a
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_WRITE_ANDX command.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2
 * subcommand TRANS2_QUERY_PATH_INFORMATION instead.
 *
 * Parameters
 * | SMB_FILE_ATTRIBUTES (2 bytes) | UTIME         | ULONG    | USHORT[5]   |
 * | FileAttributes                | LastWriteTime | FileSize | Reserved    |
 *
 * No Data
 */
static enum proto_parse_status parse_query_info_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    int word_count = parse_and_check_word_count(cursor, 0x0a);
    if(-1 == word_count) return PROTO_PARSE_ERR;
    info->meta_read_bytes = word_count * 2;
    return PROTO_OK;
}

/*
 * Set information request
 * Word count 0x08
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_WRITE_ANDX command.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2
 * subcommand TRANS2_SET_PATH_INFORMATION instead.
 *
 * Parameters
 * | SMB_FILE_ATTRIBUTES (2 bytes) | UTIME         | USHORT[5] |
 * | FileAttributes                | LastWriteTime | Reserved  |
 *
 * Data
 * | UCHAR        | SMB_STRING |
 * | BufferFormat | FileName   |
 */
static enum proto_parse_status parse_set_info_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x08)) return PROTO_PARSE_ERR;
    info->meta_write_bytes = 0x08 * 2;
    // skip parmeters
    cursor_drop(cursor, 0x08 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x2)) return PROTO_PARSE_ERR;

    // skip to smb string
    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Create request
 * Word count 0x03
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Implementations SHOULD use SMB_COM_NT_CREATE_ANDX.
 *
 * Parameters
 * | SMB_FILE_ATTRIBUTES (2 bytes) | UTIME (4 bytes) |
 * | FileAttributes                | CreationTime    |
 *
 * Data
 * | UCHAR        | SMB_STRING |
 * | BufferFormat | FileName   |
 */
static enum proto_parse_status parse_create_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x03)) return PROTO_PARSE_ERR;
    info->meta_write_bytes = 0x03 * 2;
    // skip parmeters
    cursor_drop(cursor, 0x03 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x2)) return PROTO_PARSE_ERR;

    // skip to smb string
    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Create response
 * Word count 0x01
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Implementations SHOULD use SMB_COM_NT_CREATE_ANDX.
 *
 * Parameters
 * | USHORT |
 * | FID    |
 *
 * No Data
 */
static enum proto_parse_status parse_create_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Lock byte range request
 * Word count 0x05
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_LOCKING_ANDX command.
 *
 * Parameters
 * | USHORT | ULONG              | ULONG             |
 * | FID    | CountOfBytesToLock | LockOffsetInBytes |
 *
 * No Data
 */
static enum proto_parse_status parse_lock_byte_range_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Unlock byte range request
 * Word count 0x05
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Clients SHOULD use the SMB_COM_LOCKING_ANDX command.
 *
 * Parameters
 * | USHORT | ULONG              | ULONG             |
 * | FID    | CountOfBytesToLock | LockOffsetInBytes |
 *
 * No Data
 */
static enum proto_parse_status parse_unlock_byte_range_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Create temporary request
 * Word count 0x03
 *
 * Note: This is an original Core Protocol command. This command is obsolescent.
 *
 * Parameters
 * | SMB_FILE_ATTRIBUTES (2 bytes) | UTIME (4 bytes) |
 * | FileAttributes                | CreationTime    |
 *
 * Data
 * | UCHAR        | SMB_STRING    |
 * | BufferFormat | DirectoryName |
 */
static enum proto_parse_status parse_create_temp_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x03)) return PROTO_PARSE_ERR;
    info->meta_write_bytes = 0x03 * 2;
    // skip parmeters
    cursor_drop(cursor, 0x03 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x2)) return PROTO_PARSE_ERR;

    // skip to smb string
    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Create temporary response
 * Word count 0x01
 *
 * Note: This is an original Core Protocol command. This command is obsolescent.
 *
 * Parameters
 * | USHORT |
 * | FID    |
 *
 * Data
 * | UCHAR[ByteCount]  |
 * | TemporaryFileName |
 * A null-terminated string that contains the temporary file name generated by the server.
 * The string SHOULD be a null-terminated array of ASCII characters.
 */
static enum proto_parse_status parse_create_temp_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x2)) return PROTO_PARSE_ERR;

    if(cursor_read_string(cursor, info->path, sizeof(info->path), cursor->cap_len) < 0)
        return PROTO_PARSE_ERR;
    info->set_values |= CIFS_PATH;

    return PROTO_OK;
}

/*
 * Create new request
 * Word count 0x03
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Implementations SHOULD use SMB_COM_NT_CREATE_ANDX.
 *
 * Parameters
 * | SMB_FILE_ATTRIBUTES (2 bytes) | UTIME (4 bytes) |
 * | FileAttributes                | CreationTime    |
 *
 * Data
 * | UCHAR        | SMB_STRING    |
 * | BufferFormat | DirectoryName |
 */
static enum proto_parse_status parse_create_new_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x03)) return PROTO_PARSE_ERR;
    info->meta_write_bytes = 0x03 * 2;
    // skip parmeters
    cursor_drop(cursor, 0x03 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x2)) return PROTO_PARSE_ERR;

    // skip to smb string
    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Create new response
 * Word count 0x01
 *
 * Note: This is an original Core Protocol command. This command is deprecated.
 * Implementations SHOULD use SMB_COM_NT_CREATE_ANDX.
 *
 * Parameters
 * | USHORT |
 * | FID    |
 *
 * No Data
 */
static enum proto_parse_status parse_create_new_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Seek request
 * Word count 0x04
 *
 * Parameters
 * | USHORT | USHORT | LONG   |
 * | FID    | Mode   | Offset |
 *
 * No Data
 */
static enum proto_parse_status parse_seek_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x04)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Seek response
 * Word count 0x02
 *
 * Parameters
 * | ULONG  |
 * | Offset |
 *
 * No Data
 */
static enum proto_parse_status parse_seek_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x02)) return PROTO_PARSE_ERR;
    info->meta_read_bytes = 0x02 * 2;
    return PROTO_OK;
}

/*
 * Lock and read request
 * Word count 0x05
 *
 * Note: This command is deprecated.
 * Clients SHOULD use the SMB_COM_LOCKING_ANDX command.
 *
 * Parameters
 * | USHORT | USHORT              | ULONG             |
 * | FID    | CountsOfBytesToRead | ReadOffsetInBytes |
 *
 * | USHORT                           |
 * | EstimateOfRemainingBytesToBeRead |
 *
 * No Data
 */
static enum proto_parse_status parse_lock_and_read_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Lock and read response
 * Word count 0x05
 *
 * Note: This command is deprecated.
 * Clients SHOULD use the SMB_COM_LOCKING_ANDX command.
 *
 * Parameters
 * | USHORT               | USHORT[4] |
 * | CountOfBytesReturned | Reserved  |
 *
 * Data
 * | UCHAR      | USHORT           | UCHAR[ CountOfBytesRead ] |
 * | BufferType | CountOfBytesRead | Bytes                     |
 */
static enum proto_parse_status parse_lock_and_read_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x05 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x3)) return PROTO_PARSE_ERR;

    // skip to CountOfBytesRead
    cursor_drop(cursor, 1);
    info->response_read_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Write and unlock request
 * Word count 0x05
 *
 * Note: This command is deprecated.
 * Clients SHOULD use the SMB_COM_LOCKING_ANDX command.
 *
 * Parameters
 * | USHORT | USHORT               | ULONG              |
 * | FID    | CountsOfBytesToWrite | WriteOffsetInBytes |
 *
 * | USHORT                              |
 * | EstimateOfRemainingBytesToBeWritten |
 *
 * Data
 * | UCHAR        | USHORT     | UCHAR[ DataLength ] |
 * | BufferFormat | DataLength | Data                |
 */
static enum proto_parse_status parse_write_and_unlock_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x05)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    info->query_write_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Write and unlock response
 * Word count 0x01
 *
 * Note: This command is deprecated.
 * Clients SHOULD use the SMB_COM_LOCKING_ANDX command.
 *
 * Parameters
 * | USHORT              |
 * | CountOfBytesWritten |
 *
 * No Data
 */
static enum proto_parse_status parse_write_and_unlock_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    info->response_write_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Read raw request
 * Word count 0x08 or 0x0A
 *
 * Note: This command is deprecated.
 * Clients SHOULD use the SMB_COM_READ_ANDX command.
 *
 * Parameters
 * | USHORT | ULONG  | USHORT                  | USHORT                  |
 * | FID    | Offset | MaxCountOfBytesToReturn | MinCountOfBytesToReturn |
 *
 * | ULONG   | USHORT   | ULONG                 |
 * | Timeout | Reserved | OffsetHigh (optional) |
 *
 * No Data
 */
static enum proto_parse_status parse_read_raw_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count_superior_or_equal(cursor, 0x08)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Set information2 request
 * Word count 0x07
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 subcommand
 * TRANS2_SET_FILE_INFORMATION.
 *
 * Parameters
 * | USHORT | SMB_DATE   | SMB_TIME     | SMB_DATE       | SMB_TIME       |
 * | FID    | CreateDate | CreationTime | LastAccessDate | LastAccessTime |
 *
 * | SMB_DATE      | SMB_TIME      |
 * | LastWriteDate | LastWriteTime |
 *
 * No Data
 */
static enum proto_parse_status parse_set_info2_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x07)) return PROTO_PARSE_ERR;
    info->meta_write_bytes = 0x07 * 2;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Query information2 request
 * Word count 0x01
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 subcommand
 * TRANS2_QUERY_FILE_INFORMATION.
 *
 * Parameters
 * | USHORT |
 * | FID    |
 *
 * No Data
 */
static enum proto_parse_status parse_query_info2_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Query information response
 * Word count 0x0b
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 subcommand
 * TRANS2_QUERY_FILE_INFORMATION.
 *
 * Parameters
 * | SMB_DATE   | SMB_TIME     | SMB_DATE       | SMB_TIME       |
 * | CreateDate | CreationTime | LastAccessDate | LastAccessTime |
 *
 * | SMB_DATE      | SMB_TIME      | ULONG        | ULONG              |
 * | LastWriteDate | LastWriteTime | FileDataSize | FileAllocationSize |
 *
 * | SMB_FILE_ATTRIBUTES (2 bytes) |
 * | FileAttributes                |
 *
 * No Data
 */
static enum proto_parse_status parse_query_info2_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    int word_count = parse_and_check_word_count(cursor, 0x0b);
    if(-1 == word_count) return PROTO_PARSE_ERR;
    info->meta_read_bytes = word_count * 2;
    return PROTO_OK;
}

/*
 * Write and close request
 * Word count 0x06 or 0x0c
 *
 * Note: This command is deprecated.
 * Clients SHOULD use the SMB_COM_WRITE_ANDX command.
 *
 * Parameters
 * | USHORT | USHORT               | ULONG              | UTIME         |
 * | FID    | CountsOfBytesToWrite | WriteOffsetInBytes | LastWriteTime |
 *
 * | USHORT                 |
 * | Reserved[3] (optional) |
 *
 * Data
 * | UCHAR | UCHAR[ CountOfBytesToWrte ] |
 * | Pad   | Data                        |
 */
static enum proto_parse_status parse_write_and_close_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count_superior_or_equal(cursor, 0x06)) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    info->query_write_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Write and close response
 * Word count 0x01
 *
 * Note: This command is deprecated.
 * Clients SHOULD use the SMB_COM_WRITE_ANDX command.
 *
 * Parameters
 * | USHORT              |
 * | CountOfBytesWritten |
 *
 * No Data
 */
static enum proto_parse_status parse_write_and_close_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    info->response_write_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Search request
 * Word count 0x02
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the TRANS2_FIND_FIRST2 subcommand instead.
 *
 * Parameters
 * | USHORT   | SMB_FILE_ATTRIBUTES (2 bytes) |
 * | MaxCount | SearchAttributes              |
 *
 * Data
 * | UCHAR         | SMB_STRING | UCHAR         | USHORT          |
 * | BufferFormat1 | FileName   | BufferFormat2 | ResumeKeyLength |
 *
 * | SMB_Resume_Key[ ResumeKeyLength ] |
 * | ResumeKey                         |
 */
static enum proto_parse_status parse_search_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x02)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x02 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x5)) return PROTO_PARSE_ERR;

    // skip to FileName
    cursor_drop(cursor, 1);
    // the filename immediately follows the bufferformat
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Search response
 * Word count 0x01
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the TRANS2_FIND_FIRST2 subcommand instead.
 *
 * Parameters
 * | USHORT |
 * | Count  |
 *
 * Data
 * | UCHAR        | USHORT     | SMB_Directory_Information[ DataLength ] |
 * | BufferFormat | DataLength | DirectoryInformationData                |
 */
static enum proto_parse_status parse_search_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x01 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x3)) return PROTO_PARSE_ERR;
    // drop BufferFormat
    cursor_drop(cursor, 1);

    info->meta_read_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Find request
 * Word count 0x02
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 subcommand
 * TRANS2_FIND_FIRST2 instead.
 *
 * Parameters
 * | USHORT   | SMB_FILE_ATTRIBUTES (2 bytes) |
 * | MaxCount | SearchAttributes              |
 *
 * Data
 * | UCHAR         | SMB_STRING | UCHAR         | USHORT          |
 * | BufferFormat1 | FileName   | BufferFormat2 | ResumeKeyLength |
 *
 * | SMB_Resume_Key[ ResumeKeyLength ] |
 * | ResumeKey                         |
 */
static enum proto_parse_status parse_find_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x02)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x02 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x5)) return PROTO_PARSE_ERR;

    // skip to FileName
    cursor_drop(cursor, 1);
    // the filename immediately follows the bufferformat
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Find response
 * Word count 0x01
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 subcommand
 * TRANS2_FIND_FIRST2 instead.
 *
 * Parameters
 * | USHORT |
 * | Count  |
 *
 * Data
 * | UCHAR        | USHORT     | SMB_Directory_Information[ DataLength ] |
 * | BufferFormat | DataLength | DirectoryInformationData                |
 */
static enum proto_parse_status parse_find_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x01 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x3)) return PROTO_PARSE_ERR;
    // drop BufferFormat
    cursor_drop(cursor, 1);

    info->meta_read_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Find unique request
 * Word count 0x02
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 subcommand
 * TRANS2_FIND_FIRST2 instead.
 *
 * Parameters
 * | USHORT   | SMB_FILE_ATTRIBUTES (2 bytes) |
 * | MaxCount | SearchAttributes              |
 *
 * Data
 * | UCHAR         | SMB_STRING | UCHAR         | USHORT          |
 * | BufferFormat1 | FileName   | BufferFormat2 | ResumeKeyLength |
 *
 * | SMB_Resume_Key[ ResumeKeyLength ] |
 * | ResumeKey                         |
 */
static enum proto_parse_status parse_find_unique_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x02)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x02 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x5)) return PROTO_PARSE_ERR;

    // skip to FileName
    cursor_drop(cursor, 1);
    // the filename immediately follows the bufferformat
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Find unique response
 * Word count 0x01
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 subcommand
 * TRANS2_FIND_FIRST2 instead.
 *
 * Parameters
 * | USHORT |
 * | Count  |
 *
 * Data
 * | UCHAR        | USHORT     | SMB_Directory_Information[ DataLength ] |
 * | BufferFormat | DataLength | DirectoryInformationData                |
 */
static enum proto_parse_status parse_find_unique_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x01)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x01 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x3)) return PROTO_PARSE_ERR;
    // drop BufferFormat
    cursor_drop(cursor, 1);

    info->meta_read_bytes = cursor_read_u16le(cursor);
    return PROTO_OK;
}

/*
 * Find close request
 * Word count 0x02
 *
 * Note: This command is deprecated.
 * New client implementations SHOULD use the SMB_COM_TRANSACTION2 subcommand
 * TRANS2_FIND_FIRST2 instead.
 *
 * Parameters
 * | USHORT   | SMB_FILE_ATTRIBUTES (2 bytes) |
 * | MaxCount | SearchAttributes              |
 *
 * Data
 * | UCHAR         | SMB_STRING | UCHAR         | USHORT          |
 * | BufferFormat1 | FileName   | BufferFormat2 | ResumeKeyLength |
 *
 * | SMB_Resume_Key[ ResumeKeyLength ] |
 * | ResumeKey                         |
 */
static enum proto_parse_status parse_find_close_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x02)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x02 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x1a)) return PROTO_PARSE_ERR;

    // skip to FileName
    cursor_drop(cursor, 1);
    // the filename immediately follows the bufferformat
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Nt rename request
 * Word count 0x04
 *
 * Parameters
 * | SMB_FILE_ATTRIBUTES (2 bytes) | USHORT           | ULONG    |
 * | SearchAttributes              | InformationLevel | Reserved |
 *
 * Data
 * | UCHAR         | SMB_STRING  | UCHAR         | SMB_STRING  |
 * | BufferFormat1 | OldFileName | BufferFormat2 | NewFileName |
 */
static enum proto_parse_status parse_nt_rename_request(struct cifs_parser *cifs_parser, struct cursor *cursor, struct cifs_proto_info *info)
{
    if(-1 == parse_and_check_word_count(cursor, 0x04)) return PROTO_PARSE_ERR;
    // skip parameters
    cursor_drop(cursor, 0x04 * 2);

    if(-1 == parse_and_check_byte_count_superior_or_equal(cursor, 0x04)) return PROTO_PARSE_ERR;

    // skip to OldFileName
    cursor_drop(cursor, 1 + compute_padding(cifs_parser, cursor, 1, 2));
    PARSE_SMB_PATH(info);
    return PROTO_OK;
}

/*
 * Close print file request
 * Word count 0x01 or 0x03
 *
 * Parameters
 * | USHORT | ( UTIME         | )
 * | FID    | ( LastWriteTime | )
 *
 * No Data
 */
static enum proto_parse_status parse_close_print_file_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x01);
    if (word_count != 0x01 && word_count != 0x03) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

/*
 * Ioctl request
 * Word count 0x0e or 0x03
 *
 * Parameters
 * | USHORT | USHORT   | USHORT   | USHORT              | USHORT         |
 * | FID    | Category | Function | TotalParameterCount | TotalDataCount |
 *
 * | USHORT            | USHORT       | ULONG   | USHORT   | USHORT         |
 * | MaxParameterCount | MaxDataCount | Timeout | Reserved | ParameterCount |
 *
 * | USHORT          | USHORT    | USHORT     |
 * | ParameterOffset | DataCount | DataOffset |
 *
 * Data
 * | UCHAR[] | UCHAR[ ParameterCount ] | UCHAR[] | UCHAR[ DataCount ] |
 * | Pad1    | Parameters              | Pad2    | Data               |
 *
 * Note: The request defines a function that is specific to a particular device type
 * on a particular server type. Therefore, the functions supported are not defined by
 * the protocol, but by the systems on which the CIFS implementations execute.
 * The protocol simply provides a means of delivering the requests and accepting the responses.
 *
 * The 0x03 version contains:
 * | USHORT | ULONG   |
 * | FID    | Unknown |
 */
static enum proto_parse_status parse_ioctl_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    int word_count = parse_and_check_word_count_superior_or_equal(cursor, 0x03);
    if (word_count != 0x03 && word_count != 0x0e) return PROTO_PARSE_ERR;
    cifs_set_fid(info, cursor_read_u16le(cursor));
    return PROTO_OK;
}

// SMB2 parse functions

#define READ_AND_CHECK_STRUCTURE_SIZE(expected_size) \
    CHECK(2); \
    uint16_t structure_size = cursor_read_u16le(cursor); \
    if (structure_size != expected_size) { \
        SLOG(LOG_DEBUG, "Expected structure size %"PRIu16", got %"PRIu16, expected_size, structure_size); \
        return PROTO_PARSE_ERR; \
    }


/**
 * Session setup request
 *
 * | Structure Size = 65 | SecurityMode | DialectRevision | Reserved | ServerGuid | Capabilities |
 * | 2 bytes             | 2 bytes      | 2 byte2         | 2 bytes  | 16 bytes   | 4 bytes      |
 *
 * | MaxTransactSize | MaxReadSize | MaxWriteSize | SystemTime | ServerStartTime | SecurityBufferOffset |
 * | 4 bytes         | 4 bytes     | 4 bytes      | 8 bytes    | 8 bytes         | 2 bytes              |
 *
 * | SecurityBufferLength | Reserved2 | Buffer   |
 * | 2 bytes              | 4 bytes   | variable |
 */
static enum proto_parse_status parse_smb2_negociate_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(65);
    cursor_drop(cursor, 2 + 2 + 2); // SecurityMode + DialectRevision + Reserved
    memcpy(info->hostname, cursor->head, sizeof(info->hostname));
    info->set_values |= CIFS_SERVER_HOSTNAME;
    return PROTO_OK;
}

/**
 * Session setup request
 *
 * | Structure Size = 25 | Flags  | SecurityMode | Capabilities | Channel | SecurityBufferOffset |
 * | 2 bytes             | 1 byte | 1 byte       | 4 bytes      | 4 bytes | 2 bytes              |
 *
 * | SecurityBufferLength | PreviousSessionId | Buffer   |
 * | 2 bytes              | 8 bytes           | variable |
 */
static enum proto_parse_status parse_smb2_session_setup_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(25);
    cursor_drop(cursor, 1 + 1 + 4 + 4); // flags + securitymode + capabilities + channel
    uint16_t security_buffer_offset = cursor_read_u16le(cursor);
    uint16_t security_buffer_length = cursor_read_u16le(cursor);
    uint16_t start_security_buffer = security_buffer_offset - (SMB2_HEADER_SIZE + 2 + 1 + 1 + 4 + 4 + 2 + 2);
    SLOG(LOG_DEBUG, "Security offset: %"PRIu16", security length: %"PRIu16,
            security_buffer_offset, security_buffer_length);
    CHECK(security_buffer_length + start_security_buffer);
    cursor_drop(cursor, start_security_buffer);

    return parse_security_buffer(cursor, info);
}

/**
 * Request a read operation on a file id
 *
 * | Structure Size = 49 | Padding | Flags  | Length  | Offset  | FileId   | MinimumCount |
 * | 2 bytes             | 1 byte  | 1 byte | 4 bytes | 8 bytes | 16 bytes | 4 bytes      |
 *
 * | Channel | RemainingBytes | ReadChannelInfoOffset | ReadChannelInfoLength | Buffer   |
 * | 4 bytes | 4 bytes        | 2 bytes               | 2 bytes               | Variable |
 */
static enum proto_parse_status parse_smb2_read_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(49);
    cursor_drop(cursor, 1 + 1 + 4 + 8); // Padding + flags + length + offset
    PARSE_SMB2_FID(info);
    // Don't care about the rest
    return PROTO_OK;
}

/**
 * Response of a read rquest
 *
 * | Structure Size = 17 | Data offset | Reserved | Data length | Data remaining | Reserved2 | Buffer   |
 * | 2 bytes             | 1 byte      | 1 byte   | 4 bytes     | 4 bytes        | 4 bytes   | Variable |
 */
static enum proto_parse_status parse_smb2_read_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(17);
    cursor_drop(cursor, 1 + 1); // Data offset + Reserved
    info->response_read_bytes = cursor_read_u32le(cursor);
    return PROTO_OK;
}

/**
 * Tree connect request
 *
 * | Structure Size = 9 | Reserved | Path offset | Path length | Buffer   |
 * | 2 bytes            | 2 bytes  | 2 bytes     | 2 bytes     | Variable |
 */
static enum proto_parse_status parse_smb2_tree_connect_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(9);
    cursor_drop(cursor, 2 + 2);
    uint16_t length = cursor_read_u16le(cursor);
    CHECK(length);
    PARSE_SMB2_TREE(info, length);
    SLOG(LOG_DEBUG, "Found tree path %s", info->tree);
    return PROTO_OK;
}

/**
 * Smb2 query directory request
 *
 * | Structure Size = 33 | FileInformationClass | Flags   | FileIndex | FileId   |
 * | 2 bytes             | 1 byte               | 1 bytes | 4 bytes   | 16 bytes |
 *
 * | FileNameOffset | FileNameLength | OutputBufferLength | Buffer   |
 * | 2 bytes        | 2 byte         | 4 bytes            | Variable |
 */
static enum proto_parse_status parse_smb2_query_directory_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(33);
    cursor_drop(cursor, 1 + 1 + 4); // File information + flags + file index
    PARSE_SMB2_FID(info);
    cursor_drop(cursor, 2); // offset
    uint16_t name_length = cursor_read_u16le(cursor);
    cursor_drop(cursor, 4); // Output buffer length
    PARSE_SMB2_PATH(info, name_length);
    return PROTO_OK;
}

/**
 * Smb2 query directory response
 *
 * | Structure Size = 9 | OutputBufferOffset | OutputBufferLength | Buffer   |
 * | 2 bytes            | 2 bytes            | 4 bytes            | Variable |
 */
static enum proto_parse_status parse_smb2_query_directory_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(9);
    cursor_drop(cursor, 2);
    info->meta_read_bytes = cursor_read_u32le(cursor);
    return PROTO_OK;
}

/**
 * Smb2 create request
 *
 * | Structure Size = 57 | SecurityFlags | RequestedOplockLevel | ImpersonationLevel |
 * | 2 bytes             | 1 byte        | 1 byte               | 4 bytes            |
 *
 * | SmbCreateFlags | Reserved | DesiredAccess | FileAttributes | ShareAccess | CreateDisposition |
 * | 8 bytes        | 8 bytes  | 4 bytes       | 4 bytes        | 4 bytes     | 4 bytes           |
 *
 * | CreateOptions | NameOffset | NameLength | CreateContextsOffset | CreateContextsLength | Buffer   |
 * | 4 bytes       | 2 bytes    | 2 bytes    | 4 bytes              | 4 bytes              | Variable |
 *
 */
static enum proto_parse_status parse_smb2_create_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(57);
    cursor_drop(cursor, 1 + 1 + 4 // SecurityFlags + requestedOpLockLevel + impersonationLevel
            + 8 + 8 + 4 * 4  // + smbCreateFlags + Reserved + DesiredAccess + FileAttributes + ShareAccess + CreateDisposition
            + 4 + 2 // CreateOptions + NameOffset
            );
    uint16_t name_length = cursor_read_u16le(cursor);
    cursor_drop(cursor, 4); // CreateContextOffset
    uint32_t contexts_length = cursor_read_u32le(cursor);
    PARSE_SMB2_PATH(info, name_length);
    info->meta_write_bytes = 57 + name_length + contexts_length;
    return PROTO_OK;
}

/**
 * Smb2 create response
 *
 * | StructureSize = 89 | OplockLevel | Flags  | CreateAction | CreationTime | LastAccessTime |
 * | 2 bytes            | 1 byte      | 1 byte | 4 bytes      | 8 bytes      | 8 bytes        |
 *
 * | LastWriteTime | ChangeTime | AllocationSize | EndOfFile | FileAttributes |
 * | 8 bytes       | 8 bytes    | 8 bytes        | 8 bytes   | 4 bytes        |
 *
 * | Reserved2 | FileId   | CreateContextsOffset | CreateContextsLength | Buffer   |
 * | 4 bytes   | 16 bytes | 4 bytes              | 4 bytes              | Variable |
 *
 */
static enum proto_parse_status parse_smb2_create_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(89);
    cursor_drop(cursor, 1 + 1 + 4 + 8 // OpLockLevel + Flags + CreateAction + CreationTime
            + 8 + 8 + 8 + 8 // LastAccessTime + LastWriteTime + ChangeTime + AllocationSize
            + 8 + 4 + 4 // EndOfFile + FileAttributes + Reserved2
            );
    PARSE_SMB2_FID(info);
    cursor_drop(cursor, 4); // skip CreateContextOffset
    info->meta_read_bytes = 89 + cursor_read_u32le(cursor);
    return PROTO_OK;
}

/**
 * Smb2 write request
 *
 * | StructureSize = 49 | DataOffset | Length  | Offset  | FileId   |
 * | 2 bytes            | 2 bytes    | 4 bytes | 8 bytes | 16 bytes |
 *
 * | Channel | RemainingBytes | WriteChannelInfoOffset | Flags   | Buffer   |
 * | 4 bytes | 4 bytes        | 2 bytes                | 4 bytes | Variable |
 */
static enum proto_parse_status parse_smb2_write_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(49);
    cursor_drop(cursor, 2); // Dataoffset
    info->query_write_bytes = cursor_read_u32le(cursor);
    cursor_drop(cursor, 8); // offset
    PARSE_SMB2_FID(info);
    return PROTO_OK;
}

/**
 * Smb2 write response
 *
 * | StructureSize = 17 | Reserved | Count   | Remaining | WriteChannelInfoOffset |
 * | 2 bytes            | 2 bytes  | 4 bytes | 4 bytes   | 2 bytes                |
 *
 * | WriteChannelInfoLength |
 * | 2 bytes                |
 */
static enum proto_parse_status parse_smb2_write_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(17);
    cursor_drop(cursor, 2); // Reserved
    info->response_write_bytes = cursor_read_u32le(cursor);
    return PROTO_OK;
}

/**
 * Smb2 close request
 *
 * | StructureSize = 24 | Flags   | Reserved | FileId   |
 * | 2 bytes            | 2 bytes | 4 bytes  | 16 bytes |
 */
static enum proto_parse_status parse_smb2_close_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(24);
    cursor_drop(cursor, 2 + 4); // Flags
    PARSE_SMB2_FID(info);
    return PROTO_OK;
}

/**
 * Smb2 query info request
 *
 * | StructureSize = 41 | InfoType | FileInfoClass | OutputBufferLength | InputBufferOffset |
 * | 2 bytes            | 1 byte   | 1 byte        | 4 bytes            | 2 bytes           |
 *
 * | Reserved | InputBufferLength | AdditionalInformation | Flags   | FileId   | Buffer   |
 * | 2 bytes  | 4 bytes           | 4 bytes               | 4 bytes | 16 bytes | Variable |
 */
static enum proto_parse_status parse_smb2_query_info_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(41);
    cursor_drop(cursor, 1 + 1 + 4 + 2 + 2 + 4 + 4 + 4);
    PARSE_SMB2_FID(info);
    return PROTO_OK;
}

/**
 * Smb2 query info response
 *
 * | StructureSize = 9 | OutputBufferOffset | OutputBufferLength | Buffer   |
 * | 2 bytes           | 2 bytes            | 4 bytes            | variable |
 */
static enum proto_parse_status parse_smb2_query_info_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(9);
    cursor_drop(cursor, 2);
    info->meta_read_bytes = cursor_read_u32le(cursor);
    return PROTO_OK;
}


/**
 * Smb2 flush request
 *
 * | StructureSize = 24 | Reserved1 | Reserved2 | FileID   |
 * | 2 bytes            | 2 bytes   | 2 bytes   | 16 bytes |
 */
static enum proto_parse_status parse_smb2_flush_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(24);
    cursor_drop(cursor, 2 + 2); // skip Reserved1 and Reserved2
    PARSE_SMB2_FID(info);
    return PROTO_OK;
}

/**
 * Smb2 ioctl request
 *
 * | StructureSize = 57 | Reserved | CtlCode | FileID   |
 * | 2 bytes            | 2 bytes  | 4 bytes | 16 bytes |
 *
 * | InputOffset | InputCount | MaxInputResponse | OutputOffset | OutputCount |
 * | 4 bytes     | 4 bytes    | 4 bytes          | 4 bytes      | 4 bytes     |
 *
 * | MaxOutputResponse | Flags   | Reserved2 | Buffer   |
 * | 4 bytes           | 4 bytes | 4 bytes   | variable |
 */
static enum proto_parse_status parse_smb2_ioctl_request(struct cifs_parser *cifs_parser, struct cursor *cursor,
        struct cifs_proto_info *info)
{
    uint8_t const *start_cursor = cursor->head;
    READ_AND_CHECK_STRUCTURE_SIZE(57);
    cursor_drop(cursor, 2); // skip Reserved
    enum ctl_code ctl_code = cursor_read_u32le(cursor);
    PARSE_SMB2_FID(info);

    uint32_t input_offset = cursor_read_u32le(cursor);
    uint32_t input_count = cursor_read_u32le(cursor);
    cursor_drop(cursor, 4 + 4 + 4 // skip MaxInputResponse, OutputOffset, OutputCount
                        + 4 + 4 + 4); // MaxOutputResponse, Flags, Reserved2

    switch(ctl_code) {
        case FSCTL_GET_REPARSE_POINT:
            /* This message does not contain any additional data elements. */
            break;
        case FSCTL_PIPE_TRANSCEIVE:
            /* send and receive data from an open pipe */
            info->query_write_bytes = input_count;
            break;
        case FSCTL_DFS_GET_REFERRALS:
            /*
             * DFS referral data (InputData):
             * | MaxReferralLevel | RequestFileName |
             * | 2 bytes          | variable        |
             *
             * Note: A null-terminated Unicode string specifying the path to be
             * resolved.
             */
            {
                // skip to the input buffer
                enum proto_parse_status status = PROTO_OK;
                if (PROTO_OK != (status = drop_parameter_padding(cursor, SMB2_HEADER_SIZE, start_cursor, input_offset)))
                    return status;
                // skip MaxReferralLevel
                CHECK(2);
                cursor_drop(cursor, 2);
                PARSE_SMB_PATH(info);
            }
            break;
        case FSCTL_VALIDATE_NEGOTIATE_INFO:
            /* request validation of a previous SMB2_COM_NEGOTIATE */
            break;
        case FSCTL_PIPE_WAIT:
            /*
             * InputData:
             * | Timeout | NameLength | TimeoutSpecified | Padding | Name     |
             * | 8 bytes | 4 bytes    | 1 byte           | 1 byte  | variable |
             */
            {
                // skip to the input buffer
                enum proto_parse_status status = PROTO_OK;
                if (PROTO_OK != (status = drop_parameter_padding(cursor, SMB2_HEADER_SIZE, start_cursor, input_offset)))
                    return status;

                CHECK(8 + 4 + 1 + 1);
                // drop Timeout
                cursor_drop(cursor, 8);
                uint32_t name_length = cursor_read_u32le(cursor);
                // drop TimeoutSpecified, Padding
                cursor_drop(cursor, 2 + compute_padding(cifs_parser, cursor, 2, 2));
                PARSE_SMB2_PATH(info, name_length);
            }
            break;
        case FSCTL_QUERY_NETWORK_INTERFACE_INFO:
            /* nothing to retrieve */
            break;
        case FSCTL_CREATE_OR_GET_OBJECT_ID:
            /* nothing to retrieve */
            break;
        default:
            break;
    }

    return PROTO_OK;
}


/**
 * Smb2 ioctl response
 *
 * | StructureSize = 49 | Reserved | CtlCode | FileID   |
 * | 2 bytes            | 2 bytes  | 4 bytes | 16 bytes |
 *
 * | InputOffset | InputCount | OutputOffset | OutputCount |
 * | 4 bytes     | 4 bytes    | 4 bytes      | 4 bytes     |
 *
 * | Flags   | Reserved2 | Buffer   |
 * | 4 bytes | 4 bytes   | variable |
 */
static enum proto_parse_status parse_smb2_ioctl_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(49);
    cursor_drop(cursor, 2); // skip Reserved
    enum ctl_code ctl_code = cursor_read_u32le(cursor);
    PARSE_SMB2_FID(info);
    cursor_drop(cursor, 4 + 4 + 4); // skip InputOffset, InputCount, OutputOffset
    uint32_t output_count = cursor_read_u32le(cursor);
    cursor_drop(cursor, 4 + 4); // Flags, Reserved2

    switch(ctl_code) {
        case FSCTL_DFS_GET_REFERRALS:
            /* nothing to retrieve */
            break;
        case FSCTL_PIPE_TRANSCEIVE:
            info->response_read_bytes = output_count;
            break;
        case FSCTL_PIPE_WAIT:
            /* The following FSCTL responses do not provide an output buffer:
             *  - FSCTL_PIPE_WAIT
             *  - FSCTL_LMR_REQUEST_RESILIENCY
             */
            break;
        case FSCTL_QUERY_NETWORK_INTERFACE_INFO:
            info->meta_read_bytes = output_count;
            break;
        case FSCTL_CREATE_OR_GET_OBJECT_ID:
            info->meta_read_bytes = output_count;
            break;
        case FSCTL_VALIDATE_NEGOTIATE_INFO:
            /* nothing to retrieve */
            break;
        default:
            break;
    }

    return PROTO_OK;
}

/**
 * Smb2 lock request
 *
 * | StructureSize = 48 | LockCount | LockSequence | FileID   |
 * | 2 bytes            | 2 bytes   | 4 bytes      | 16 bytes |
 *
 * | Locks    |
 * | variable |
 */
static enum proto_parse_status parse_smb2_lock_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(48);
    cursor_drop(cursor, 2 + 4); // skip LockCount, LockSequence
    PARSE_SMB2_FID(info);
    return PROTO_OK;
}

/**
 * Smb2 change notify request
 *
 * | StructureSize = 32 | Flags   | OutputBufferLength | FileID   |
 * | 2 bytes            | 2 bytes | 4 bytes            | 16 bytes |
 *
 * | CompletionFilter | Reserved |
 * | 4 bytes          | 4 bytes  |
 */
static enum proto_parse_status parse_smb2_change_notify_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(32);
    cursor_drop(cursor, 2 + 4); // skip Flags, OutputBufferLength
    PARSE_SMB2_FID(info);
    return PROTO_OK;
}

/**
 * Smb2 change notify response
 *
 * | StructureSize = 9 | OutputBufferOffset | OutputBufferLength |
 * | 2 bytes           | 2 bytes            | 4 bytes            |
 *
 * | Buffer   |
 * | variable |
 */
static enum proto_parse_status parse_smb2_change_notify_response(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(9);
    cursor_drop(cursor, 2); // skip OutputBufferOffset
    info->meta_read_bytes = cursor_read_u32le(cursor);
    return PROTO_OK;
}

/**
 * Smb2 set info request
 *
 * | StructureSize = 33 | InfoType | FileInfoClass | BufferLength |
 * | 2 bytes            | 1 byte   | 1 byte        | 4 bytes      |
 *
 * | BufferOffset | Reserved | AdditionalInformation | FileId   | Buffer   |
 * | 2 bytes      | 2 bytes  | 4 bytes               | 16 bytes | variable |
 */
static enum proto_parse_status parse_smb2_set_info_request(struct cifs_parser unused_ *cifs_parser,
        struct cursor *cursor,
        struct cifs_proto_info *info)
{
    READ_AND_CHECK_STRUCTURE_SIZE(33);
    cursor_drop(cursor, 1 + 1); // skip InfoType, FileInfoClass
    info->meta_write_bytes = cursor_read_u32le(cursor);
    cursor_drop(cursor, 2 + 2 + 4); // skip BufferOffset, Reserved, AdditionalInformation
    PARSE_SMB2_FID(info);
    return PROTO_OK;
}

typedef enum proto_parse_status command_parser(struct cifs_parser *cifs_parser,
        struct cursor *cursor, struct cifs_proto_info *info);

struct smb_command_parser {
    command_parser *request;
    command_parser *response;
};

struct smb_command_parser smb_command_parsers[255] = { };

struct smb_command_parser smb2_command_parsers[19] = {
//    SMB2_COM_NEGOTIATE,
    { NULL, parse_smb2_negociate_response },
//    SMB2_COM_SESSION_SETUP,
    { parse_smb2_session_setup_request, NULL },
//    SMB2_COM_LOGOFF,
    { NULL, NULL },
//    SMB2_COM_TREE_CONNECT,
    { parse_smb2_tree_connect_request, NULL },
//    SMB2_COM_TREE_DISCONNECT,
    { NULL, NULL },
//    SMB2_COM_CREATE,
    { parse_smb2_create_request, parse_smb2_create_response },
//    SMB2_COM_CLOSE,
    { parse_smb2_close_request, NULL },
//    SMB2_COM_FLUSH,
    { parse_smb2_flush_request, NULL },
//    SMB2_COM_READ,
    { parse_smb2_read_request, parse_smb2_read_response },
//    SMB2_COM_WRITE,
    { parse_smb2_write_request, parse_smb2_write_response },
//    SMB2_COM_LOCK,
    { parse_smb2_lock_request, NULL },
//    SMB2_COM_IOCTL,
    { parse_smb2_ioctl_request, parse_smb2_ioctl_response },
//    SMB2_COM_CANCEL,
    { NULL, NULL },
//    SMB2_COM_ECHO,
    { NULL, NULL },
//    SMB2_COM_QUERY_DIRECTORY,
    { parse_smb2_query_directory_request, parse_smb2_query_directory_response },
//    SMB2_COM_CHANGE_NOTIFY,
    { parse_smb2_change_notify_request, parse_smb2_change_notify_response },
//    SMB2_COM_QUERY_INFO,
    { parse_smb2_query_info_request, parse_smb2_query_info_response },
//    SMB2_COM_SET_INFO,
    { parse_smb2_set_info_request, NULL },
//    SMB2_COM_OPLOCK_BREAK,
    { NULL, NULL },
};

static enum proto_parse_status smb2_parse(struct cursor *cursor, struct cifs_proto_info *info,
        struct cifs_parser *cifs_parser)
{
    (void) cifs_parser;
    SLOG(LOG_DEBUG, "Parse of a smb2 message");
    if (cursor->cap_len < SMB2_HEADER_SIZE) return PROTO_TOO_SHORT;
    struct smb2_hdr const *smb2_hdr = (struct smb2_hdr const *) cursor->head;
    info->command.smb2_command = READ_U16LE(&smb2_hdr->command);
    if (info->command.smb2_command > SMB2_COM_OPLOCK_BREAK) {
        SLOG(LOG_DEBUG, "Invalid command 0x%"PRIx16, info->command.smb2_command);
        return PROTO_PARSE_ERR;
    }
    if (!(smb2_hdr->flags & SMB2_FLAGS_ASYNC_COMMAND)) {
        info->tree_id = READ_U32LE(&smb2_hdr->u2.sync.tree_id);
    }
    if (!info->is_query) {
        info->status = READ_U32LE(&smb2_hdr->u1.status);
    }
    info->ids.message_id = READ_U64LE(&smb2_hdr->message_id);
    cursor_drop(cursor, SMB2_HEADER_SIZE);
    enum proto_parse_status status = PROTO_OK;
    if (info->status != SMB_STATUS_OK) {
        // TODO parse error message
    } else {
        SLOG(LOG_DEBUG, "Got smb2 command %s", smb2_command_2_str(info->command.smb2_command));
        command_parser *fun;
        if (info->is_query) fun = smb2_command_parsers[info->command.smb2_command].request;
        else fun = smb2_command_parsers[info->command.smb2_command].response;
        if (fun) status = fun(cifs_parser, cursor, info);
    }

    if (status != PROTO_OK)
        SLOG(LOG_DEBUG, "Problem when parsing cifs: %s", proto_parse_status_2_str(status));

    return status;
}

static enum proto_parse_status smb_parse(struct cursor *cursor, struct cifs_proto_info *info, struct cifs_parser *cifs_parser)
{
    SLOG(LOG_DEBUG, "Parse of a smb message");
    if (cursor->cap_len < SMB_HEADER_SIZE) return PROTO_TOO_SHORT;

    struct smb_hdr const *smb_hdr = (struct smb_hdr const *) cursor->head;

#define SMB_FLAGS2_UNICODE 0x8000
    cifs_parser->unicode = smb_hdr->flags2 & SMB_FLAGS2_UNICODE;
    info->command.smb_command = READ_U8(&smb_hdr->command);
    info->status = READ_U32LE(&smb_hdr->status);
    info->tree_id = READ_U16LE(&smb_hdr->tree_id);
    info->ids.multiplex_id = READ_U16LE(&smb_hdr->multiplex_id);

    cursor_drop(cursor, SMB_HEADER_SIZE);

    SLOG(LOG_DEBUG, "Parse of a cifs command %s (0x%02x), cifs_parser %s",
            smb_command_2_str(info->command.smb_command),
            info->command.smb_command, cifs_parser_2_str(cifs_parser));
    enum proto_parse_status status = PROTO_OK;
    if (info->status != SMB_STATUS_OK) {
        // TODO parse error message?
    } else {
        command_parser *fun;
        if (info->is_query) fun = smb_command_parsers[info->command.smb_command].request;
        else fun = smb_command_parsers[info->command.smb_command].response;
        if (fun) status = fun(cifs_parser, cursor, info);
    }

    if (status != PROTO_OK)
        SLOG(LOG_DEBUG, "Problem when parsing cifs: %s", proto_parse_status_2_str(status));

    return status;
}

static enum proto_parse_status cifs_parse(struct parser *parser, struct proto_info *parent,
        unsigned way, uint8_t const *packet, size_t cap_len, size_t unused_ wire_len,
        struct timeval const *now, size_t tot_cap_len, uint8_t const *tot_packet)
{
    if (cap_len < 4) return PROTO_TOO_SHORT;
    uint32_t smb_version = READ_U32N(packet);
    struct cifs_parser *cifs_parser = DOWNCAST(parser, parser, cifs_parser);

    struct cifs_proto_info info;
    bool is_query = !way;
    ASSIGN_INFO_OPT(tcp, parent);
    if (tcp) is_query = tcp->to_srv;

    struct cursor cursor;
    ASSIGN_INFO_CHK(netbios, parent, PROTO_PARSE_ERR);
    cursor_ctor(&cursor, packet, netbios->size);

    enum proto_parse_status status = PROTO_OK;
    switch (smb_version) {
        case CIFS_SMB_HEADER:
            cifs_proto_info_ctor(&info, &cifs_parser->parser, parent, SMB_HEADER_SIZE,
                    netbios->size - SMB_HEADER_SIZE, is_query, SMB_VERSION_1,
                    &netbios->first_packet_tv);
            status = smb_parse(&cursor, &info, cifs_parser);
            break;
        case CIFS_SMB2_HEADER:
            cifs_proto_info_ctor(&info, &cifs_parser->parser, parent, SMB2_HEADER_SIZE,
                    netbios->size - SMB2_HEADER_SIZE, is_query, SMB_VERSION_2,
                    &netbios->first_packet_tv);
            status = smb2_parse(&cursor, &info, cifs_parser);
            break;
        default:
            return PROTO_PARSE_ERR;
    }

    SLOG(LOG_DEBUG, "Parsed result: %s, cifs proto %s", proto_parse_status_2_str(status)
            , cifs_info_2_str(&info.info));
    if(status == PROTO_OK)
        status = proto_parse(NULL, &info.info, !info.is_query, NULL, 0, 0, now, tot_cap_len, tot_packet);
    return status;
}

static struct uniq_proto uniq_proto_cifs;
struct proto *proto_cifs = &uniq_proto_cifs.proto;

/*
 * Initialization
 */

void cifs_init(void)
{
    log_category_proto_cifs_init();

    static struct proto_ops const ops = {
        .parse      = cifs_parse,
        .parser_new = cifs_parser_new,
        .parser_del = cifs_parser_del,
        .info_2_str = cifs_info_2_str,
        .info_addr  = cifs_info_addr,
    };
    uniq_proto_ctor(&uniq_proto_cifs, &ops, "CIFS", PROTO_CODE_CIFS);
    pthread_key_create(&iconv_pthread_key, (void (*)(void *))iconv_close);

    smb_command_parsers[SMB_COM_SESSION_SETUP_ANDX].request      = parse_session_setup_andx_query;
    smb_command_parsers[SMB_COM_SESSION_SETUP_ANDX].response     = parse_session_setup_andx_response;
    smb_command_parsers[SMB_COM_TREE_CONNECT_ANDX].request       = parse_tree_connect_andx_request_query;
    smb_command_parsers[SMB_COM_NEGOCIATE].response              = parse_negociate_response;
    smb_command_parsers[SMB_COM_TRANSACTION2].request            = parse_trans2_request;
    smb_command_parsers[SMB_COM_TRANSACTION2].response           = parse_trans2_response;
    smb_command_parsers[SMB_COM_TRANSACTION2_SECONDARY].request  = parse_trans2_secondary_request;
    smb_command_parsers[SMB_COM_WRITE_ANDX].request              = parse_write_andx_request;
    smb_command_parsers[SMB_COM_WRITE_ANDX].response             = parse_write_andx_response;
    smb_command_parsers[SMB_COM_CLOSE].request                   = parse_close_request;
    smb_command_parsers[SMB_COM_DELETE].request                  = parse_delete_request;
    smb_command_parsers[SMB_COM_DELETE_DIRECTORY].request        = parse_delete_directory_request;
    smb_command_parsers[SMB_COM_READ_ANDX].request               = parse_read_andx_request;
    smb_command_parsers[SMB_COM_READ_ANDX].response              = parse_read_andx_response;
    smb_command_parsers[SMB_COM_NT_CREATE_ANDX].request          = parse_nt_create_andx_request;
    smb_command_parsers[SMB_COM_NT_CREATE_ANDX].response         = parse_nt_create_andx_response;
    smb_command_parsers[SMB_COM_FLUSH].request                   = parse_flush_request;
    smb_command_parsers[SMB_COM_RENAME].request                  = parse_rename_request;
    smb_command_parsers[SMB_COM_LOCKING_ANDX].request            = parse_locking_andx_request;
    smb_command_parsers[SMB_COM_OPEN_ANDX].request               = parse_open_andx_request;
    smb_command_parsers[SMB_COM_OPEN_ANDX].response              = parse_open_andx_response;
    smb_command_parsers[SMB_COM_NT_TRANSACT].request             = parse_nt_transact_request;
    smb_command_parsers[SMB_COM_NT_TRANSACT].response            = parse_nt_transact_response;
    smb_command_parsers[SMB_COM_TRANSACTION].request             = parse_transaction_request;
    smb_command_parsers[SMB_COM_TRANSACTION].response            = parse_transaction_response;
    smb_command_parsers[SMB_COM_WRITE].request                   = parse_write_request;
    smb_command_parsers[SMB_COM_WRITE].response                  = parse_write_response;
    smb_command_parsers[SMB_COM_READ].request                    = parse_read_request;
    smb_command_parsers[SMB_COM_READ].response                   = parse_read_response;
    smb_command_parsers[SMB_COM_CREATE_DIRECTORY].request        = parse_create_directory_request;
    smb_command_parsers[SMB_COM_QUERY_INFORMATION_DISK].response = parse_query_info_disk_response;
    smb_command_parsers[SMB_COM_CHECK_DIRECTORY].request         = parse_check_directory_request;
    smb_command_parsers[SMB_COM_OPEN].request                    = parse_open_request;
    smb_command_parsers[SMB_COM_OPEN].response                   = parse_open_response;
    smb_command_parsers[SMB_COM_QUERY_INFORMATION].request       = parse_query_info_request;
    smb_command_parsers[SMB_COM_QUERY_INFORMATION].response      = parse_query_info_response;
    smb_command_parsers[SMB_COM_SET_INFORMATION].request         = parse_set_info_request;
    smb_command_parsers[SMB_COM_CREATE].request                  = parse_create_request;
    smb_command_parsers[SMB_COM_CREATE].response                 = parse_create_response;
    smb_command_parsers[SMB_COM_LOCK_BYTE_RANGE].request         = parse_lock_byte_range_request;
    smb_command_parsers[SMB_COM_UNLOCK_BYTE_RANGE].request       = parse_unlock_byte_range_request;
    smb_command_parsers[SMB_COM_CREATE_TEMPORARY].request        = parse_create_temp_request;
    smb_command_parsers[SMB_COM_CREATE_TEMPORARY].response       = parse_create_temp_response;
    smb_command_parsers[SMB_COM_CREATE_NEW].request              = parse_create_new_request;
    smb_command_parsers[SMB_COM_CREATE_NEW].response             = parse_create_new_response;
    smb_command_parsers[SMB_COM_SEEK].request                    = parse_seek_request;
    smb_command_parsers[SMB_COM_SEEK].response                   = parse_seek_response;
    smb_command_parsers[SMB_COM_LOCK_AND_READ].request           = parse_lock_and_read_request;
    smb_command_parsers[SMB_COM_LOCK_AND_READ].response          = parse_lock_and_read_response;
    smb_command_parsers[SMB_COM_WRITE_AND_UNLOCK].request        = parse_write_and_unlock_request;
    smb_command_parsers[SMB_COM_WRITE_AND_UNLOCK].response       = parse_write_and_unlock_response;
    smb_command_parsers[SMB_COM_READ_RAW].request                = parse_read_raw_request;
    smb_command_parsers[SMB_COM_SET_INFORMATION2].request        = parse_set_info2_request;
    smb_command_parsers[SMB_COM_QUERY_INFORMATION2].request      = parse_query_info2_request;
    smb_command_parsers[SMB_COM_QUERY_INFORMATION2].response     = parse_query_info2_response;
    smb_command_parsers[SMB_COM_WRITE_AND_CLOSE].request         = parse_write_and_close_request;
    smb_command_parsers[SMB_COM_WRITE_AND_CLOSE].response        = parse_write_and_close_response;
    smb_command_parsers[SMB_COM_SEARCH].request                  = parse_search_request;
    smb_command_parsers[SMB_COM_SEARCH].response                 = parse_search_response;
    smb_command_parsers[SMB_COM_FIND].request                    = parse_find_request;
    smb_command_parsers[SMB_COM_FIND].response                   = parse_find_response;
    smb_command_parsers[SMB_COM_FIND_UNIQUE].request             = parse_find_unique_request;
    smb_command_parsers[SMB_COM_FIND_UNIQUE].response            = parse_find_unique_response;
    smb_command_parsers[SMB_COM_FIND_CLOSE].request              = parse_find_close_request;
    smb_command_parsers[SMB_COM_NT_RENAME].request               = parse_nt_rename_request;
    smb_command_parsers[SMB_COM_CLOSE_PRINT_FILE].request        = parse_close_print_file_request;
    smb_command_parsers[SMB_COM_IOCTL].request                   = parse_ioctl_request;
}

void cifs_fini(void)
{
#   ifdef DELETE_ALL_AT_EXIT
    uniq_proto_dtor(&uniq_proto_cifs);
    pthread_key_delete(iconv_pthread_key);
#   endif
    log_category_proto_cifs_fini();
}

